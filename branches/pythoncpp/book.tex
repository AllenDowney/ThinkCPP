% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 2011  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\documentclass{book}
\usepackage{epsfig}
\usepackage{makeidx}
\pssilent

\title{How to think like a computer scientist}

\author{Allen B. Downey}
\date{}

\sloppy
\setlength{\topmargin}{0.75in}
\setlength{\headsep}{0.5in}
\setlength{\oddsidemargin}{1.0in}
\setlength{\evensidemargin}{.95in}
\makeindex

\begin{document}

\title {How to think like a computer scientist}
\author {Allen B. Downey}
\date {C++ Version, First Edition}
\maketitle

\vspace{2in}
\begin{center}
{\Large How to think like a computer scientist}

C++ Version, First Edition
\vspace{0.25in}

Copyright (C) 2011  Allen B. Downey
\end{center}
\vspace{0.25in}

Permission is
granted to reproduce, store or transmit the text of this
book by any means, electrical, mechanical, or biological,
in accordance with the terms of the GNU General Public License as
published by the Free Software Foundation (version 2).

This book is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

The original form of this book is LaTeX source code.
Compiling this LaTeX source has the effect of generating
a device-independent representation of a textbook, which
can be converted to other formats and printed.  All intermediate
representations (including DVI and Postscript), and all printed
copies of the textbook are also covered by the GNU General
Public License.

The LaTeX source for this book is available from

???

The GNU General Public License is available from
www.gnu.org or by writing to the Free Software Foundation,
Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

This book was typeset by the author using LaTeX and dvips,
which are both free, open-source programs.


\frontmatter
\tableofcontents

\mainmatter

\chapter{The way of the program}

The goal of this book is to teach you to think like a
computer scientist.  I like the way computer scientists think because
they combine some of the best features of Mathematics, Engineering,
and Natural Science.  Like mathematicians, computer scientists use formal
languages to denote ideas (specifically computations).  Like
engineers, they design things, assembling components into systems and
evaluating tradeoffs among alternatives.  Like scientists,
they observe the behavior of complex systems, form hypotheses, and test
predictions.

The single most important skill for a computer scientist is {\bf
problem-solving}.  By that I mean the ability to formulate problems,
think creatively about solutions, and express a solution clearly and
accurately.  As it turns out, the process of learning to program is an
excellent opportunity to practice problem-solving skills.  That's why
this chapter is called ``The way of the program.''

Of course, the other goal of this book is to prepare you for the
Computer Science AP Exam.  We may not take the most direct approach
to that goal, though.  For example, there are not many exercises in
this book that are similar to the AP questions.  On the other hand,
if you understand the concepts in this book, along with the details
of programming in C++, you will have all the tools you need to
do well on the exam.

\section{What is a programming language?}
\index{programming language}
\index{language!programming}

The programming language you will be learning is C++, because that is
the language the AP exam is based on, as of 1998.  Before that, the
exam used Pascal.  Both C++ and Pascal are {\bf high-level languages};
other high-level languages you might have heard of are Java, C and
FORTRAN.

As you might infer from the name ``high-level language,'' there are
also {\bf low-level languages}, sometimes referred to as machine
language or assembly language.  Loosely-speaking, computers can only
execute programs written in low-level languages.  Thus, programs
written in a high-level language have to be translated before they can
run.  This translation takes some time, which is a small disadvantage
of high-level languages.

\index{portability}
\index{high-level language}
\index{low-level language}
\index{language!high-level}
\index{language!low-level}

But the advantages are enormous.  First,
it is {\em much} easier to program in a high-level language;
by ``easier'' I mean that the program takes less time to write,
it's shorter and easier to read, and it's more likely to be
correct.  Secondly, high-level languages are {\bf portable},
meaning that they can run on different kinds of computers with
few or no modifications.  Low-level programs can only run
on one kind of computer, and have to be rewritten to run on
another.

Due to these advantages, almost all programs are written in
high-level languages.  Low-level languages are only used for
a few special applications.

\index{compile}
\index{interpret}

There are two ways to translate a program; {\bf interpreting} or {\bf
compiling}.  An interpreter is a program that reads a high-level
program and does what it says.  In effect, it translates the program
line-by-line, alternately reading lines and carrying out commands.

\vspace{0.1in}
\centerline{\epsfig{figure=interpret.eps}}
\vspace{0.1in}

A compiler is a program that reads a high-level program and
translates it all at once, before executing any of the commands.
Often you compile the program as a separate step, and then
execute the compiled code later.  In this case, the high-level
program is called the {\bf source code}, and the translated
program is called the {\bf object code} or the {\bf executable}.

As an example, suppose you write a program in C++.  You might
use a text editor to write the program (a text editor is
a simple word processor).  When the program is finished, you
might save it in a file named {\tt program.cpp}, where ``program''
is an arbitrary name you make up, and the suffix {\tt .cpp} is
a convention that indicates that the file contains C++ source
code.

Then, depending on what your programming environment is like,
you might leave the text editor and run the compiler.  The
compiler would read your source code, translate it, and create
a new file named {\tt program.o} to contain the object code,
or {\tt program.exe} to contain the executable. 

\vspace{0.1in}
\centerline{\epsfig{figure=compile.eps}}
\vspace{0.1in}

The next step is to run the program, which requires some kind
of executor.  The role of the executor is to load the program
(copy it from disk into memory) and make the computer start
executing the program.

Although this process may seem complicated, the good news is that in
most programming environments (sometimes called development
environments), these steps are automated for you.  Usually you will
only have to write a program and type a single command to compile and
run it.  On the other hand, it is useful to know what the steps are
that are happening in the background, so that if something goes wrong
you can figure out what it is.

\section{What is a program?}

A program is a sequence of instructions that specifies how to perform
a computation.  The computation might be something mathematical, like
solving a system of equations or finding the roots of a polynomial,
but it can also be a symbolic computation, like searching and
replacing text in a document or (strangely enough) compiling a
program.

\index{statement}

The instructions (or commands, or statements) look different in
different programming languages, but there are a few basic functions
that appear in just about every language:

\begin{description}

\item[input:] Get data from the keyboard, or a file, or some
other device.

\item[output:] Display data on the screen or send data to a
file or other device.

\item[math:] Perform basic mathematical operations like addition and
multiplication.

\item[testing:] Check for certain conditions and execute the
appropriate sequence of statements.

\item[repetition:] Perform some action repeatedly, usually with
some variation.

\end{description}

Believe it or not, that's pretty much all there is to it.
Every program you've ever used, no matter how complicated, is
made up of functions that look more or less like these.  Thus,
one way to describe programming is the process of breaking a
large, complex task up into smaller and smaller subtasks
until eventually the subtasks are simple enough to be performed
with one of these simple functions.

\section{What is debugging?}
\index{debugging}
\index{bug}

Programming is a complex process, and since it is done by
human beings, it often leads to errors.  For whimsical reasons,
programming errors are called {\bf bugs} and the process
of tracking them down and correcting them is called
{\bf debugging}.

There are a few different kinds of errors that can occur
in a program, and it is useful to distinguish between them
in order to track them down more quickly.

\subsection{Compile-time errors}
\index{compile-time error}
\index{error!compile-time}

The compiler can only translate a program if the program is
syntactically correct; otherwise, the compilation fails and
you will not be able to run your program.  {\bf Syntax}
refers to the structure of your program and the rules about
that structure.

\index{syntax}

For example, in English, a sentence must begin with a capital
letter and end with a period.  this sentence contains a syntax
error.  So does this one

For most readers, a few syntax errors are not a significant
problem, which is why we can read the poetry of e e cummings
without spewing error messages.

Compilers are not so forgiving.  If there is a single syntax
error anywhere in your program, the compiler will print an
error message and quit, and you will not be able to run
your program.

To make matters worse, there are more syntax rules in C++
than there are in English, and the error messages you get from
the compiler are often not very helpful.  During the first
few weeks of your programming career, you will probably
spend a lot of time tracking down syntax errors.  As you
gain experience, though, you will make fewer errors and find
them faster.

\subsection{Run-time errors}
\label{run-time}
\index{run-time error}
\index{error!run-time}
\index{safe language}
\index{language!safe}

The second type of error is a run-time error, so-called because
the error does not appear until you run the program.

For the simple sorts of programs we will be writing for the
next few weeks, run-time errors are rare, so it might be a little
while before you encounter one.


\subsection{Logic errors and semantics}
\index{semantics}
\index{logic error}
\index{error!logic}

The third type of error is the {\bf logical} or {\bf semantic}
error.  If there is a logical error in your program, it will
compile and run successfully, in the sense that the computer
will not generate any error messages, but it will not do the
right thing.  It will do something else.  Specifically, it will
do what you told it to do.

The problem is that the program you wrote is not the program
you wanted to write.  The meaning of the program (its semantics)
is wrong.  Identifying logical errors can be tricky, since
it requires you to work backwards by looking at the output
of the program and trying to figure out what it is doing.

\subsection{Experimental debugging}

One of the most important skills you should acquire from working with
this book is debugging.  Although it can be frustrating, debugging is
one of the most intellectually rich, challenging, and interesting
parts of programming.

In some ways debugging is like detective work.  You are
confronted with clues and you have to infer the processes
and events that lead to the results you see.

Debugging is also like an experimental science.  Once you have an idea
what is going wrong, you modify your program and try again.  If your
hypothesis was correct, then you can predict the result of the
modification, and you take a step closer to a working program.  If
your hypothesis was wrong, you have to come up with a new one.  As
Sherlock Holmes pointed out, ``When you have eliminated the
impossible, whatever remains, however improbable, must be the truth.''
(from A. Conan Doyle's {\em The Sign of Four}).

\index{Holmes, Sherlock}
\index{Doyle, Arthur Conan}

For some people, programming and debugging are the
same thing.  That is, programming is the process of gradually
debugging a program until it does what you want.  The idea
is that you should always start with a working program that
does {\em something}, and make small modifications, debugging
them as you go, so that you always have a working program.

For example, Linux is an operating system that contains thousands of
lines of code, but it started out as a simple program Linus Torvalds
used to explore the Intel 80386 chip.  According to Larry Greenfield,
``One of Linus's earlier projects was a program that would switch
between printing AAAA and BBBB.  This later evolved to Linux''
(from {\em The Linux Users' Guide} Beta Version 1).

\index{Linux}

In later chapters I will make more suggestions about debugging
and other programming practices.

\section{Formal and natural languages}
\label{formal}
\index{formal language}
\index{natural language}
\index{language!formal}
\index{language!natural}

{\bf Natural languages} are the languages that people speak,
like English, Spanish, and French.  They were not designed
by people (although people try to impose some order on them);
they evolved naturally.

{\bf Formal languages} are languages that are designed by people for
specific applications.  For example, the notation that mathematicians
use is a formal language that is particularly good at denoting
relationships among numbers and symbols.  Chemists use a formal
language to represent the chemical structure of molecules.  And
most importantly:

\begin{quote}
{\bf Programming languages are formal languages that have been
designed to express computations.}
\end{quote}

As I mentioned before, formal languages tend to have strict rules
about syntax.  For example, $3+3=6$ is a syntactically correct
mathematical statement, but $3=+6\$$ is not.  Also, $H_2O$ is a
syntactically correct chemical name, but $_2Zz$ is not.

Syntax rules come in two flavors, pertaining to tokens and structure.
Tokens are the basic elements of the language, like words and numbers
and chemical elements.  One of the problems with {\tt 3=+6\$} is that
{\tt \$} is not a legal token in mathematics (at least as far as I
know).  Similarly, $_2Zz$ is not legal because there is no element with
the abbreviation $Zz$.

The second type of syntax error pertains to the structure of a
statement; that is, the way the tokens are arranged.  The statement
{\tt 3=+6\$} is structurally illegal, because you can't have a plus
sign immediately after an equals sign.  Similarly, molecular formulas
have to have subscripts after the element name, not before.

When you read a sentence in English or a statement in a formal
language, you have to figure out what the structure of the sentence is
(although in a natural language you do this unconsciously).  This
process is called {\bf parsing}.

\index{parse}

For example, when you hear the sentence, ``The other shoe fell,'' you
understand that ``the other shoe'' is the subject and ``fell'' is the
verb.  Once you have parsed a sentence, you can figure out what it
means, that is, the semantics of the sentence.  Assuming that you know
what a shoe is, and what it means to fall, you will understand the
general implication of this sentence.

Although formal and natural languages have many features in
common---tokens, structure, syntax and semantics---there are many
differences.

\index{ambiguity}
\index{redundancy}
\index{literalness}

\begin{description}

\item[ambiguity:] Natural languages are full of ambiguity, which
people deal with by using contextual clues and other information.
Formal languages are designed to be nearly or completely unambiguous,
which means that any statement has exactly one meaning,
regardless of context.

\item[redundancy:] In order to make up for ambiguity and reduce
misunderstandings, natural languages employ lots of
redundancy.  As a result, they are often verbose.  Formal languages
are less redundant and more concise.

\item[literalness:] Natural languages are full of idiom and
metaphor.  If I say, ``The other shoe fell,'' there is probably
no shoe and nothing falling.  Formal languages mean
exactly what they say.

\end{description}

People who grow up speaking a natural language (everyone) often have a
hard time adjusting to formal languages.  In some ways the difference
between formal and natural language is like the difference between
poetry and prose, but more so:

\index{poetry}
\index{prose}

\begin{description}

\item[Poetry:] Words are used for their sounds as well as for
their meaning, and the whole poem together creates an effect or
emotional response.  Ambiguity is not only common but often
deliberate.

\item[Prose:] The literal meaning of words is more important
and the structure contributes more meaning.  Prose is more amenable to
analysis than poetry, but still often ambiguous.

\item[Programs:] The meaning of a computer program is unambiguous
and literal, and can be understood entirely by analysis of the
tokens and structure.

\end{description}

Here are some suggestions for reading programs (and other formal
languages).  First, remember that formal languages are much more dense
than natural languages, so it takes longer to read them.  Also, the
structure is very important, so it is usually not a good idea to read
from top to bottom, left to right.  Instead, learn to parse the
program in your head, identifying the tokens and interpreting the
structure.  Finally, remember that the details matter.  Little things
like spelling errors and bad punctuation, which you can get away
with in natural languages, can make a big difference in a formal
language.

\section{The first program}
\label{hello}
\index{hello world}

Traditionally the first program people write in a new language
is called ``Hello, World.'' because all it does is print the
words ``Hello, World.''  In C++, this program looks like this:

\begin{verbatim}
#include <iostream>
using namespace std;

// main: generate some simple output

int main ()
{
  cout << "Hello, world." << endl;
  return 0;
}
\end{verbatim}
%
Some people judge the quality of a programming language by
the simplicity of the ``Hello, World.'' program.  By this
standard, C++ does reasonably well.  Even so, this simple
program contains several features that are hard to explain to
beginning programmers.  For now, we will ignore some of
them, like the first two lines.

\index{comment}
\index{statement!comment}

The third line begins with {\tt //}, which indicates
that it is a {\bf comment}.  A comment is a bit of
English text that you can put in the middle of a program,
usually to explain what the program does.  When the compiler
sees a {\tt //}, it ignores everything from there until the end
of the line.

In the fourth line, you can ignore the word {\tt int}
for now, but notice the word {\tt main}.  {\tt main} is a
special name that indicates the place in the program where execution
begins.  When the program runs, it starts by executing the first
statement in {\tt main} and it continues, in order, until it gets
to the last statement, and then it quits.

\index{output}
\index{statement!output}

There is no limit to the number of statements that can be in {\tt
main}, but the example contains only one.  It is a basic {\bf
output} statement, meaning that it outputs or displays a message on
the screen.  

{\tt cout} is a special object provided by the system to allow
you to send output to the screen.  The symbol {\tt <<} is an
{\bf operator} that you apply to {\tt cout} and a string, and that
causes the string to be displayed.

\index{operator}

{\tt endl} is a special symbol that represents the end of a
line.  When you send an {\tt endl} to {\tt cout}, it causes the
cursor to move to the next line of the display.
The next time you output something, the new text appears
on the next line.

Like all statements, the output statement ends with a
semi-colon ({\tt ;}).

There are a few other things you should notice about the syntax of
this program.  First, C++ uses squiggly-braces (\{ and
\}) to group things together.  In this case, the output statement
is enclosed in squiggly-braces, indicating that it is {\em inside} the
definition of {\tt main}.  Also, notice that the statement is
indented, which helps to show visually which lines are inside the
definition.

At this point it would be a good idea to sit down in front of
a computer and compile and run this program.  The details of how
to do that depend on your programming environment, but from now
on in this book I will assume that you know how to do it.

As I mentioned, the C++ compiler is a real stickler for syntax.
If you make any errors when you type in the program, chances
are that it will not compile successfully.  For example, if
you misspell {\tt iostream}, you might get an error message like
the following:

\begin{verbatim}
hello.cpp:1: oistream.h: No such file or directory
\end{verbatim}
%
There is a lot of information on this line, but it is presented
in a dense format that is not easy to interpret.  A more friendly
compiler might say something like:

\begin{quote}
``On line 1 of the source code file named hello.cpp, you tried to
include a header file named oistream.h.  I didn't find anything
with that name, but I did find something named iostream.  Is
that what you meant, by any chance?''
\end{quote}

Unfortunately, few compilers are so accomodating.  The compiler
is not really very smart, and in most cases the error message
you get will be only a hint about what is wrong.  It will take
some time to gain facility at interpreting compiler messages.

Nevertheless, the compiler can be a useful tool for learning the
syntax rules of a language.  Starting with a working program
(like hello.cpp), modify it in various ways and see what happens.
If you get an error message, try to remember what the message says
and what caused it, so if you see it again in the future you
will know what it means.

\section{Glossary}

\begin{description}

\item[problem-solving:]  The process of formulating a problem, finding
a solution, and expressing the solution.

\item[high-level language:]  A programming language like C++ that
is designed to be easy for humans to read and write.

\item[low-level language:]  A programming language that is designed
to be easy for a computer to execute.  Also called ``machine
language'' or ``assembly language.''

\item[portability:]  A property of a program that can run on more
than one kind of computer.

\item[formal language:]  Any of the languages people have designed
for specific purposes, like representing mathematical ideas or
computer programs.  All programming languages are formal languages.

\item[natural language:]  Any of the languages people speak that
have evolved naturally.

\item[interpret:]  To execute a program in a high-level language
by translating it one line at a time.

\item[compile:]  To translate a program in a high-level language
into a low-level language, all at once, in preparation for later
execution.

\item[source code:]  A program in a high-level language, before
being compiled.

\item[object code:]  The output of the compiler, after translating
the program.

\item[executable:]  Another name for object code that is ready
to be executed.

\item[algorithm:]  A general process for solving a category of
problems. 

\item[bug:]  An error in a program.

\item[syntax:]  The structure of a program.

\item[semantics:]  The meaning of a program.

\item[parse:]  To examine a program and analyze the syntactic structure.

\item[syntax error:]  An error in a program that makes it impossible
to parse (and therefore impossible to compile).

\item[run-time error:]  An error in a program that makes it fail at
run-time.

\item[logical error:]  An error in a program that makes it do something
other than what the programmer intended.

\item[debugging:]  The process of finding and removing any of
the three kinds of errors.

\index{problem-solving}
\index{high-level language}
\index{low-level language}
\index{formal language}
\index{natural language}
\index{interpret}
\index{compile}
\index{syntax}
\index{semantics}
\index{parse}
\index{error}
\index{debugging}

\end{description}



% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{Variables and types}

\section{More output}
\index{output}
\index{statement!output}

As I mentioned in the last chapter, you can put as many statements as
you want in {\tt main}.  For example, to output more than one line:

\begin{verbatim}
#include <iostream>
using namespace std;
// main: generate some simple output

int main ()
{
  cout << "Hello, world." << endl;     // output one line
  cout << "How are you?" << endl;      // output another
  return 0;
}
\end{verbatim}
%
As you can see, it is legal to put comments at the
end of a line, as well as on a line by themselves.

\index{String}
\index{type!String}

The phrases that appear in quotation marks are called {\bf strings},
because they are made up of a sequence (string) of letters.  Actually,
strings can contain any combination of letters, numbers, punctuation
marks, and other special characters.

\index{newline}

Often it is useful to display the output from multiple output
statements all on one line.  You can do this by leaving out
the first {\tt endl}:

\begin{verbatim}
int main ()
{
  cout << "Goodbye, ";
  cout << "cruel world!" << endl;
  return 0
}
\end{verbatim}
%
In this case the output appears on a single line as
{\tt Goodbye, cruel world!}.  Notice that there is a space
between the word ``Goodbye,'' and the second quotation mark.
This space appears in the output, so it affects the behavior
of the program.

Spaces that appear outside of quotation marks generally do
not affect the behavior of the program.  For example, I
could have written:

\begin{verbatim}
int main ()
{
  cout<<"Goodbye, ";
  cout<<"cruel world!"<<endl;
  return 0;
}
\end{verbatim}
%
This program would compile and run just as well as the original.
The breaks at the ends of lines (newlines) do not affect
the program's behavior either, so I could have written:

\begin{verbatim}
int main(){cout<<"Goodbye, ";cout<<"cruel world!"<<endl;return 0;}
\end{verbatim}
%
That would work, too, although you have probably noticed that
the program is getting harder and harder to read.  Newlines and
spaces are useful for organizing your program visually, making
it easier to read the program and locate syntax errors.

\section{Values}
\index{value}
\index{type}

A value is one of the fundamental things---like a letter or
a number---that a program manipulates.  The only values we have
manipulated so far are the string values we have been outputting, like
{\tt "Hello, world."}.  You (and the compiler) can identify
string values because they are enclosed in quotation marks.

There are other kinds of values, including integers and characters.
An integer is a whole number like 1 or 17.  You can output
integer values the same way you output strings:

\begin{verbatim}
  cout << 17 << endl;
\end{verbatim}
%
A character value is a letter or digit or punctuation mark
enclosed in single quotes, like {\tt 'a'} or {\tt '5'}.
You can output character values the same way:

\begin{verbatim}
  cout << '}' << endl;
\end{verbatim}
%
This example outputs a single close squiggly-brace on a line
by itself.

It is easy to confuse different types of values, like {\tt "5"}, {\tt
'5'} and {\tt 5}, but if you pay attention to the punctuation, it
should be clear that the first is a string, the second is a character
and the third is an integer.  The reason this distinction is important
should become clear soon.

\section {Variables}
\index{variable}
\index{value}

One of the most powerful features of a programming language is the
ability to manipulate {\bf variables}.  A variable is a named location
that stores a value.  

Just as there are different types of values (integer, character,
etc.), there are different types of variables.  When you create a new
variable, you have to declare what type it is.  For example, the
character type in C++ is called {\tt char}.  The following statement
creates a new variable named {\tt fred} that has type {\tt char}.

\begin{verbatim}
    char fred;
\end{verbatim}
%
This kind of statement is called a {\bf declaration}.

The type of a variable determines what kind of values it can
store.  A {\tt char} variable can contain characters, and it should
come as no surprise that {\tt int} variables can store integers.

There are several types in C++ that can store string values, but we
are going to skip that for now (see Chapter~\ref{strings}).

\index{declaration}
\index{statement!declaration}

To create an integer variable, the syntax is 

\begin{verbatim}
  int bob;
\end{verbatim}
%
where {\tt bob} is the arbitrary name you made up for the
variable.  In general, you will want to make up variable names
that indicate what you plan to do with the variable.  For
example, if you saw these variable declarations:

\begin{verbatim}
    char firstLetter;
    char lastLetter;
    int hour, minute;
\end{verbatim}
%
you could probably make a good guess at what values
would be stored in them.  This example
also demonstrates the syntax for declaring multiple variables
with the same type: {\tt hour} and {\tt minute}
are both integers ({\tt int} type).

\section{Assignment}
\index{assignment}
\index{statement!assignment}

Now that we have created some variables, we would like to
store values in them.  We do that with an {\bf assignment
statement}.

\begin{verbatim}
    firstLetter = 'a';   // give firstLetter the value 'a'
    hour = 11;           // assign the value 11 to hour
    minute = 59;         // set minute to 59
\end{verbatim}
%
This example shows three assignments, and the comments show
three different ways people sometimes talk about assignment
statements.  The vocabulary can be confusing here, but the
idea is straightforward:

\begin{itemize}

\item When you declare a variable, you create a named storage location.

\item When you make an assignment to a variable, you give it a value.

\end{itemize}

A common way to represent variables on paper is to draw a box
with the name of the variable on the outside and the value
of the variable on the inside.  This kind of figure is called
a {\bf state diagram} because is shows what state each of the
variables is in (you can think of it as the variable's ``state of
mind'').
This diagram shows
the effect of the three assignment statements:

\vspace{0.1in}
\centerline{\epsfig{figure=assign.eps}}
\vspace{0.1in}

I sometimes use different shapes to indicate different
variable types.  These shapes should help remind you that one of the
rules in C++ is that a variable has to have the same type as the
value you assign it.  For example, you cannot store a string in
an {\tt int} variable.  The following statement generates a compiler
error.

\begin{verbatim}
  int hour;
  hour = "Hello.";       // WRONG !!
\end{verbatim}
%
This rule is sometimes a source of confusion, because there are many
ways that you can convert values from one type to another, and C++
sometimes converts things automatically.  But for now you should
remember that as a general rule variables and values have the same
type, and we'll talk about special cases later.

Another source of confusion is that some strings {\em look}
like integers, but they are not.  For example,
the string {\tt "123"}, which is made up of the
characters {\tt 1}, {\tt 2} and {\tt 3}, is not
the same thing as the {\em number} {\tt 123}.
This assignment is illegal:

\begin{verbatim}
  minute = "59";         // WRONG!
\end{verbatim}
%
\section{Outputting variables}
\label{output}

You can output the value of a variable using the same commands
we used to output simple values.

\begin{verbatim}
  int hour, minute;
  char colon;

  hour = 11;
  minute = 59;
  colon = ':';

  cout << "The current time is ";
  cout << hour;
  cout << colon;
  cout << minute;
  cout << endl;
\end{verbatim}
%
This program creates two integer variables named {\tt hour} and {\tt
minute}, and a character variable named {\tt colon}.  It assigns
appropriate values to each of the variables and then uses a series
of output statements to generate the following:

\begin{verbatim}
The current time is 11:59
\end{verbatim}

When we talk about ``outputting a variable,'' we mean outputting the
{\em value} of the variable.  To output the {\em name} of a variable,
you have to put it in quotes.  For example: {\tt cout << "hour";}

As we have seen before, you can include more than one value in
a single output statement, which can make the previous program more
concise:

\begin{verbatim}
  int hour, minute;
  char colon;

  hour = 11;
  minute = 59;
  colon = ':';

  cout << "The current time is " << hour << colon << minute << endl;
\end{verbatim}
%
On one line, this program outputs a string, two integers, a character,
and the special value {\tt endl}.  Very impressive!

\section{Keywords}
\index{keyword}

A few sections ago, I said that you can make up any name you
want for your variables, but that's not quite true.  There
are certain words that are reserved in C++ because they are
used by the compiler to parse the structure of your program,
and if you use them as variable names, it will get confused.
These words, called {\bf keywords}, include {\tt int},
{\tt char}, {\tt void}, {\tt endl} and many more.

The complete list of keywords is included in the C++ Standard, which
is the official language definition adopted by the the International
Organization for Standardization (ISO) on September 1, 1998.  You
can download a copy electronically from

\begin{verbatim}
    http://www.ansi.org/
\end{verbatim}
%
Rather than memorize the list, I would suggest that you
take advantage of a feature provided in many development
environments: code highlighting.  As you type, different
parts of your program should appear in different colors.  For
example, keywords might be blue, strings red, and other code
black.  If you type a variable name and it turns blue, watch
out!  You might get some strange behavior from the compiler.

\section{Operators}
\index{operator}

{\bf Operators} are special symbols that are used to represent
simple computations like addition and multiplication.  Most
of the operators in C++ do exactly what you would expect them
to do, because they are common mathematical symbols.  For
example, the operator for adding two integers is {\tt +}.

The following are all legal C++ expressions whose meaning is
more or less obvious:

\begin{verbatim}
1+1        hour-1       hour*60 + minute     minute/60
\end{verbatim}
%
Expressions can contain both variables
names and integer values.  In each case the name of the variable is
replaced with its value before the computation is performed.

\index{expression}

Addition, subtraction and multiplication all do what you
expect, but you might be surprised by division.  For example,
the following program:

\begin{verbatim}
  int hour, minute;
  hour = 11;
  minute = 59;
  cout << "Number of minutes since midnight: ";
  cout << hour*60 + minute << endl;
  cout << "Fraction of the hour that has passed: ";
  cout << minute/60 << endl;
\end{verbatim}
%
would generate the following output:

\begin{verbatim}
Number of minutes since midnight: 719
Fraction of the hour that has passed: 0
\end{verbatim}
%
The first line is what we expected, but the second line is
odd.  The value of the variable {\tt minute} is 59, and
59 divided by 60 is 0.98333, not 0.  The reason for the
discrepancy is that C++ is performing {\bf integer division}.

\index{type!int}
\index{integer division}
\index{arithmetic!integer}
\index{division!integer}
\index{operand}

When both of the {\bf operands} are integers (operands are the things
operators operate on), the result must also be an integer,
and by definition integer division always rounds {\em down},
even in cases like this where the next integer is so close.

A possible alternative in this case is to calculate a percentage
rather than a fraction:

\begin{verbatim}
  cout << "Percentage of the hour that has passed: ";
  cout << minute*100/60 << endl;
\end{verbatim}
%
The result is:

\begin{verbatim}
Percentage of the hour that has passed: 98
\end{verbatim}
%
Again the result is rounded down, but at least now the answer
is approximately correct.  In order to get an even more accurate
answer, we could use a different type of variable, called
floating-point, that is capable of storing fractional values.
We'll get to that in the next chapter.

\section{Order of operations}
\index{precedence}
\index{order of operations}

When more than one operator appears in an expression the order
of evaluation depends on the rules of {\bf precedence}.  A
complete explanation of precedence can get complicated, but
just to get you started:

\begin{itemize}

\item Multiplication and division happen before
addition and subtraction.  So {\tt 2*3-1} yields 5, not 4, and {\tt
2/3-1} yields -1, not 1 (remember that in integer division {\tt 2/3}
is 0).

\item If the operators have the same precedence they are evaluated
from left to right.  So in the expression {\tt minute*100/60},
the multiplication happens first, yielding {\tt 5900/60}, which
in turn yields {\tt 98}.  If the operations had gone from right
to left, the result would be {\tt 59*1} which is {\tt 59}, which
is wrong.

\item Any time you want to override the rules of precedence (or
you are not sure what they are) you can use parentheses.  Expressions
in parentheses are evaluated first, so {\tt 2 * (3-1)} is 4.
You can also use parentheses to make an expression easier to
read, as in {\tt (minute * 100) / 60}, even though it doesn't
change the result.

\end{itemize}

\section{Operators for characters}
\index{character operator}
\index{operator!character}

Interestingly, the same mathematical operations that work on
integers also work on characters.  For example,

\begin{verbatim}
  char letter;
  letter = 'a' + 1;
  cout << letter << endl;
\end{verbatim}
%
outputs the letter {\tt b}.  Although it is syntactically legal
to multiply characters, it is almost never useful to do it.

Earlier I said that you can only assign integer values to
integer variables and character values to character variables,
but that is not completely true.  In some cases, C++ converts
automatically between types.  For example, the following is
legal.

\begin{verbatim}
  int number;
  number = 'a';
  cout << number << endl;
\end{verbatim}
%
The result is 97, which is the number that is used internally
by C++ to represent the letter {\tt 'a'}.  However, it is
generally a good idea to treat characters as characters, and
integers as integers, and only convert from one to the other
if there is a good reason.

Automatic type conversion is an example of a common problem in designing a
programming language, which is that there is a conflict between {\bf
formalism}, which is the requirement that formal languages should have
simple rules with few exceptions, and {\bf convenience}, which is the
requirement that programming languages be easy to use in practice.

More often than not, convenience wins, which is usually good for
expert programmers, who are spared from rigorous but unwieldy
formalism, but bad for beginning programmers, who are often baffled
by the complexity of the rules and the number of exceptions.  In this
book I have tried to simplify things by emphasizing the rules and
omitting many of the exceptions.


\section{Composition}
\index{composition}
\index{expression}

So far we have looked at the elements of a programming
language---variables, expressions, and statements---in
isolation, without talking about how to combine them.

One of the most useful features of programming languages
is their ability to take small building blocks and
{\bf compose} them.  For example, we know how to multiply
integers and we know how to output values; it turns out we can
do both at the same time:

\begin{verbatim}
    cout << 17 * 3;
\end{verbatim}
%
Actually, I shouldn't say ``at the same time,'' since in reality
the multiplication has to happen before the output, but
the point is that any expression, involving numbers, characters,
and variables, can be used inside an output statement.  We've
already seen one example:

\begin{verbatim}
  cout << hour*60 + minute << endl;
\end{verbatim}
%
You can also put arbitrary expressions on the right-hand
side of an assignment statement:

\begin{verbatim}
  int percentage;
  percentage = (minute * 100) / 60;
\end{verbatim}
%
This ability may not seem so impressive now, but we will see
other examples where composition makes it possible
to express complex computations neatly and concisely.

WARNING: There are limits on where you can use certain
expressions; most notably, the left-hand side of an assignment
statement has to be a {\em variable} name, not an expression.
That's because the left side indicates the storage location
where the result will go.  Expressions
do not represent storage locations, only values.  So the
following is illegal:  {\tt minute+1 = hour;}.

\section{Glossary}

\begin{description}

\item[variable:] A named storage location for values.  All
variables have a type, which determines which values it can
store.

\item[value:] A letter, or number, or other thing that can be
stored in a variable.  

\item[type:] A set of values.  The types
we have seen are integers ({\tt int} in C++) and characters ({\tt
char} in C++).

\item[keyword:]  A reserved word that is used by the compiler
to parse programs.  Examples we have seen include {\tt int},
{\tt void} and {\tt endl}.

\item[statement:] A line of code that represents a command or
action.  So far, the statements we have seen are declarations,
assignments, and output statements.

\item[declaration:] A statement that creates a new variable and
determines its type.

\item[assignment:] A statement that assigns a value to a variable.

\item[expression:] A combination of variables, operators and
values that represents a single result value.  Expressions also
have types, as determined by their operators and operands.

\item[operator:] A special symbol that represents a simple
computation like addition or multiplication.

\item[operand:] One of the values on which an operator operates. 

\item[precedence:] The order in which operations are evaluated.

\item[composition:] The ability to combine simple
expressions and statements into compound statements and expressions
in order to represent complex computations concisely.

\index{variable}
\index{value}
\index{type}
\index{keyword}
\index{statement}
\index{assignment}
\index{expression}
\index{operator}
\index{operand}
\index{composition}

\end{description}


% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{Functions}

\section{Floating-point}
\index{floating-point number}
\index{type!double}
\index{double (floating-point)}

In the last chapter we had some problems dealing with numbers
that were not integers.  We worked around the problem by measuring
percentages instead of fractions, but a more general solution is
to use floating-point numbers, which can represent fractions
as well as integers.  In C++, there are two floating-point types,
called {\tt float} and {\tt double}.  In this book we will use
{\tt double}s exclusively.

You can create floating-point variables and assign values to them
using the same syntax we used for the other types.  For example:

\begin{verbatim}
  double pi;
  pi = 3.14159;
\end{verbatim}
%
It is also legal to declare a variable and assign a value to it at the
same time:

\begin{verbatim}
  int x = 1;
  String empty = "";
  double pi = 3.14159;
\end{verbatim}
%
In fact, this syntax is quite common.  A combined declaration
and assignment is sometimes called an {\bf initialization}.

\index{initialization}

Although floating-point numbers are useful, they are
often a source of confusion because there seems to be an
overlap between integers and floating-point numbers.  For
example, if you have the value {\tt 1}, is that an integer,
a floating-point number, or both?

Strictly speaking, C++ distinguishes the integer value {\tt 1}
from the floating-point value {\tt 1.0}, even though they
seem to be the same number.  They belong to
different types, and strictly speaking, you are not allowed
to make assignments between types.  For example, the following
is illegal

\begin{verbatim}
    int x = 1.1;
\end{verbatim}
%
because the variable on the left is an {\tt int}
and the value on the right is a {\tt double}.  But it is easy
to forget this rule, especially because there are places where C++
automatically converts from one type to another.
For example,

\begin{verbatim}
    double y = 1;
\end{verbatim}
%
should technically not be legal, but C++ allows it by converting the
{\tt int} to a {\tt double} automatically.  This leniency is
convenient, but it can cause problems; for example:

\begin{verbatim}
    double y = 1 / 3;
\end{verbatim}
%
You might expect the variable {\tt y} to be given the value
{\tt 0.333333}, which is a legal floating-point value, but in
fact it will get the value {\tt 0.0}.  The reason is that the
expression on the right appears to be the ratio of two integers,
so C++ does {\em integer} division, which yields the integer
value {\tt 0}.  Converted to floating-point, the result is
{\tt 0.0}.

One way to solve this problem (once you figure out what
it is) is to make the right-hand side a floating-point
expression:

\begin{verbatim}
    double y = 1.0 / 3.0;
\end{verbatim}
%
This sets {\tt y} to {\tt 0.333333}, as expected.

\index{arithmetic!floating-point}

All the operations we have seen---addition, subtraction,
multiplication, and division---work on floating-point values,
although you might be interested to know that the underlying mechanism
is completely different.  In fact, most processors have special
hardware just for performing floating-point operations.

\section{Converting from {\tt double} to {\tt int}}
\label{rounding}
\index{rounding}
\index{typecasting}

As I mentioned, C++ converts {\tt int}s
to {\tt double}s automatically if necessary, because no
information is lost in the translation.  On the other hand,
going from a {\tt double} to an {\tt int} requires rounding
off.  C++ doesn't perform this operation automatically, in
order to make sure that you, as the programmer, are aware
of the loss of the fractional part of the number.

The simplest way to convert a floating-point value to an integer is to
use a {\bf typecast}.  Typecasting is so called because it allows you
to take a value that belongs to one type and ``cast'' it into another
type (in the sense of molding or reforming, not throwing).

The syntax for typecasting is like the syntax
for a function call.  For example:

\begin{verbatim}
  double pi = 3.14159;
  int x = int (pi);
\end{verbatim}
%
The {\tt int} function returns an integer, so {\tt x} gets the value
3.  Converting to an integer always rounds down, even if the fraction
part is 0.99999999.

For every type in C++, there is a corresponding function that
typecasts its argument to the appropriate type.

\section{Math functions}
\index{Math function}
\index{function!Math}
\index{expression}
\index{argument}

In mathematics, you have probably seen functions like $\sin$ and
$\log$, and you have learned to evaluate expressions like
$\sin(\pi/2)$ and $\log(1/x)$.  First, you evaluate the
expression in parentheses, which is called the {\bf argument} of the
function.  For example, $\pi/2$ is approximately 1.571, and $1/x$ is
0.1 (if $x$ happens to be 10).

Then you can evaluate the function itself, either by looking it up in
a table or by performing various computations.  The $\sin$ of 1.571 is
1, and the $\log$ of 0.1 is -1 (assuming that $\log$ indicates the
logarithm base 10).

This process can be applied repeatedly to evaluate more complicated
expressions like $\log(1/\sin(\pi/2))$.  First we evaluate the
argument of the innermost function, then evaluate the function,
and so on.

C++ provides a set of built-in functions that includes most
of the mathematical operations you can think of.
The math functions are invoked using a syntax that is similar to
mathematical notation:

\begin{verbatim}
     double log = log (17.0);
     double angle = 1.5;
     double height = sin (angle);
\end{verbatim}
%
The first example sets {\tt log} to the logarithm of 17, base
$e$.  There is also a function called {\tt log10} that takes
logarithms base 10.

The second example finds the sine of the value of the variable
{\tt angle}.  C++ assumes that the
values you use with {\tt sin} and the other trigonometric functions
({\tt cos}, {\tt tan}) are in {\em radians}.  To
convert from degrees to radians, you can divide by 360
and multiply by $2 \pi$.  

If you don't happen to know $\pi$ to 15 digits, you can
calculate it using the {\tt acos} function.  The arccosine
(or inverse cosine) of -1 is $\pi$, because the cosine of
$\pi$ is -1.

\begin{verbatim}
  double pi = acos(-1.0);
  double degrees = 90;
  double angle = degrees * 2 * pi / 360.0;
\end{verbatim}
%
Before you can use any of the math functions, you have to
include the math {\bf header file}.  Header files contain
information the compiler needs about functions that are defined
outside your program.  For example, in the ``Hello, world!''
program we included a header file named {\tt iostream} using
an {\bf include} statement:

\begin{verbatim}
#include <iostream>
using namespace std;
\end{verbatim}
%
{\tt iostream} contains information about input and output
(I/O) streams, including the object named {\tt cout}.
C++ has a powerful feature called namespaces, that
allow you to write your own implementation of {\tt cout}.
But in most cases, we would need to use the standard implementation.
To convey this to the compiler, we use the line

\begin{verbatim}
using namespace std;
\end{verbatim}

As a rule of the thumb, you should write {\tt using namespace std;} whenever
you use {\tt iostream}.
\index{header file}
\index{cmath}
\index{iostream}

Similarly, the math header file contains information
about the math functions.  You can include it at the beginning
of your program along with {\tt iostream}:

\begin{verbatim}
#include <cmath>
\end{verbatim}

Such header files have an initial `c' to signify that these
header files have been derived from the {\bf C} language.

\section {Composition}
\label{composition}
\index{composition}
\index{expression}

Just as with mathematical functions, C++ functions can be {\bf
composed}, meaning that you use one expression as part of another.
For example, you can use any expression as an argument to a function:

\begin{verbatim}
    double x = cos (angle + pi/2);
\end{verbatim}
%
This statement takes the value of {\tt pi}, divides it by two and
adds the result to the value of {\tt angle}.  The sum is
then passed as an argument to the {\tt cos} function.

You can also take the result of one function and pass it as
an argument to another:

\begin{verbatim}
    double x = exp (log (10.0));
\end{verbatim}
%
This
statement finds the log base $e$ of 10 and then raises $e$ to that
power.  The result gets assigned to {\tt x}; I hope you know what it
is.

\section{Adding new functions}
\index{function!definition}
\index{main}
\index{function!main}

So far we have only been using the functions that are built into C++,
but it is also possible to add new functions.  Actually, we have already
seen one function definition: {\tt main}.  The function named {\tt main}
is special because it indicates where the execution of the program
begins, but the syntax for {\tt main} is the same as for any other
function definition:

\begin{verbatim}
  void NAME ( LIST OF PARAMETERS ) {
    STATEMENTS
  }
\end{verbatim}
%
You can make up any name you want for your function, except
that you can't call it {\tt main} or any other
C++ keyword.  The list of
parameters specifies what information, if any, you have to
provide in order to use (or {\bf call}) the new function.

{\tt main} doesn't take any parameters, as indicated by
the empty parentheses {\tt ()} in it's definition.  The first couple
of functions we are going to write also have no parameters, so the
syntax looks like this:

\begin{verbatim}
  void newLine () {
    cout << endl;
  }
\end{verbatim}
%
This function is named {\tt newLine}; it contains only a single
statement, which outputs a newline character, represented by
the special value {\tt endl}.

In {\tt main} we can call this new function using syntax that
is similar to the way we call the built-in C++ commands:

\begin{verbatim}
int main ()
{
  cout << "First Line." << endl;
  newLine ();
  cout << "Second Line." << endl;
  return 0;
}
\end{verbatim}
%
The output of this program is

\begin{verbatim}
First line.

Second line.
\end{verbatim}
%
Notice the extra space between the two lines.  What if we wanted
more space between the lines?  We could call the same
function repeatedly:

\begin{verbatim}
int main ()
{
  cout << "First Line." << endl;
  newLine ();
  newLine ();
  newLine ();
  cout << "Second Line." << endl;
  return 0;
}
\end{verbatim}
%
Or we could write a new function, named {\tt threeLine}, that 
prints three new lines:

\begin{verbatim}
void threeLine ()
{
  newLine ();  newLine ();  newLine ();
}

int main ()
{
  cout << "First Line." << endl;
  threeLine ();
  cout << "Second Line." << endl;
  return 0;
}
\end{verbatim}
%
You should notice a few things about this program:

\begin{itemize}

\item You can call the same procedure repeatedly.  In
fact, it is quite common and useful to do so.

\item You can have one function call another function.  In this
case, {\tt main} calls {\tt threeLine} and {\tt threeLine}
calls {\tt newLine}.  Again, this is common and useful.

\item In {\tt threeLine} I wrote three statements all on the
same line, which is syntactically legal (remember that spaces
and new lines usually don't change the meaning of a program).
On the other hand, it is usually a better idea to put each
statement on a line by itself, to make your program easy to
read.  I sometimes break that rule in this book to save space.

\end{itemize}

So far, it may not be clear why it is worth the trouble to
create all these new functions.  Actually, there are a lot
of reasons, but this example only demonstrates two:

\begin{enumerate}

\item Creating a new function gives you an opportunity to
give a name to a group of statements.  Functions can simplify a program
by hiding a complex computation behind a single command, and by using
English words in place of arcane code.  Which is clearer, {\tt
newLine} or {\tt cout << endl}?

\item Creating a new function can make a program smaller by eliminating
repetitive code.  For example, a short way to print nine consecutive
new lines is to call {\tt threeLine} three times.  How would you
print 27 new lines?

\end{enumerate}

\section {Definitions and uses}

Pulling together all the code fragments from the previous
section, the whole program looks like this:

\begin{verbatim}
#include <iostream>
using namespace std;

void newLine ()
{
  cout << endl;
}

void threeLine ()
{
  newLine ();  newLine ();  newLine ();
}

int main ()
{
  cout << "First Line." << endl;
  threeLine ();
  cout << "Second Line." << endl;
  return 0;
}
\end{verbatim}

This program contains three function definitions: {\tt newLine},
{\tt threeLine}, and {\tt main}.

Inside the definition of {\tt main}, there is a statement that
uses or calls {\tt threeLine}.  Similarly, {\tt threeLine} calls
{\tt newLine} three times.  Notice that the definition of each
function appears above the place where it is used.

This is necessary in C++; the definition of a function must
appear before (above) the first use of the function.  You
should try compiling this program with the functions in a
different order and see what error messages you get.

\section {Programs with multiple functions}

When you look at a class definition that contains several functions, it
is tempting to read it from top to bottom, but that is likely to be
confusing, because that is not the {\bf order of execution} of the
program.

Execution always begins at the first statement of {\tt main},
regardless of where it is in the program (often it is at the bottom).
Statements are executed one at a time, in order, until you reach a
function call.  Function calls are like a detour in the flow of
execution.  Instead of going to the next statement, you go to the
first line of the called function, execute all the statements there,
and then come back and pick up again where you left off.

That sounds simple enough, except that you have to remember that one
function can call another.  Thus, while we are in the middle of {\tt
main}, we might have to go off and execute the statements in {\tt
threeLine}.  But while we are executing {\tt threeLine}, we get
interrupted three times to go off and execute {\tt newLine}.

Fortunately, C++ is adept at keeping track of where it is, so
each time {\tt newLine} completes, the program picks up where it left
off in {\tt threeLine}, and eventually gets back to {\tt main} so the
program can terminate.

What's the moral of this sordid tale?  When you read a program, don't
read from top to bottom.  Instead, follow the flow of execution.

\section {Parameters and arguments}
\index{parameter}
\index{argument}

Some of the built-in functions we have used have {\bf parameters},
which are values that you provide to let the function do its
job.  For example, if you want to find the sine of a number,
you have to indicate what the number is.  Thus, {\tt sin}
takes a {\tt double} value as a parameter.

Some functions take more than one parameter, like {\tt pow},
which takes two {\tt doubles}, the base and the exponent.

Notice that in each of these cases we have to specify not
only how many parameters there are, but also what type they
are.  So it shouldn't surprise you that when you write a
class definition, the parameter list indicates the type of
each parameter.  For example:

\begin{verbatim}
  void printTwice (char phil) {
    cout << phil << phil << endl;
  }
\end{verbatim}
%
This function takes a single parameter, named {\tt phil}, that
has type {\tt char}.  Whatever that parameter is (and at
this point we have no idea what it is), it gets printed
twice, followed by a newline.
I chose the name {\tt phil} to suggest that the name
you give a parameter is up to you, but in general you want to
choose something more illustrative than {\tt phil}.

In order to call this function, we have to provide a {\tt char}.
For example, we might have a {\tt main} function like this:

\begin{verbatim}
  int main () {
    printTwice ('a');
    return 0;
  }
\end{verbatim}
%
The {\tt char} value you provide is called an {\bf argument}, and we
say that the argument is {\bf passed} to the function.  In this
case the value {\tt 'a'} is passed as an argument
to {\tt printTwice} where it will get printed twice.

Alternatively, if we had a {\tt char} variable, we could
use it as an argument instead:

\begin{verbatim}
  int main () {
    char argument = 'b';
    printTwice (argument);
    return 0;
  }
\end{verbatim}
%
Notice something very important here: the name of the variable we pass
as an argument ({\tt argument}) has nothing to do with the name of the
parameter ({\tt phil}).  Let me say that again:

\begin{quote}

{\bf The name of the variable we pass as an argument has nothing to do
with the name of the parameter.}

\end{quote}

They can be the same or they can be different, but it is important
to realize that they are not the same thing, except that they happen
to have the same value (in this case the character {\tt 'b'}).

The value you provide as an argument must have the same type as
the parameter of the function you call.  This rule is
important, but it is sometimes confusing because C++ sometimes
converts arguments from one type to another automatically.  For
now you should learn the general rule, and we will deal with
exceptions later.

\section {Parameters and variables are local}

Parameters and
variables only exist inside their own functions.  Within the
confines of {\tt main}, there is no such thing as {\tt phil}.
If you try to use it, the compiler will complain.  Similarly,
inside {\tt printTwice} there is no such thing as {\tt argument}.

Variables like this are said to be {\bf local}.  In order to
keep track of parameters and local variables, it is useful to
draw a {\bf stack diagram}.  Like state diagrams, stack diagrams
show the value of each variable, but the variables are contained
in larger boxes that indicate which function they belong to.

For example, the state diagram for {\tt printTwice} looks 
like this:

\vspace{0.1in}
\centerline{\epsfig{figure=stack.eps}}
\vspace{0.1in}
%
Whenever a function is called, it creates a new {\bf instance}
of that function.  Each instance of a function contains the
parameters and local variables for that function.  In the
diagram an instance of a function is represented by a box
with the name of the function on the outside and the variables
and parameters inside.

In the example, {\tt main} has one local variable, {\tt argument}, and
no parameters.  {\tt printTwice} has no local variables and one
parameter, named {\tt phil}.

\section {Functions with multiple parameters}
\index{parameter!multiple}
\index{function!multiple parameter}
\index{class!Time}

The syntax for declaring and invoking functions with multiple
parameters is a common source of errors.  First, remember
that you have to declare the type of every parameter.  For
example

\begin{verbatim}
  void printTime (int hour, int minute) {
    cout << hour;
    cout << ":";
    cout << minute;
  }
\end{verbatim}
%
It might be tempting to write {\tt (int hour, minute)}, but
that format is only legal for variable declarations, not
for parameters.

Another common source of confusion is that you do not have
to declare the types of arguments.  The following is wrong!

\begin{verbatim}
    int hour = 11;
    int minute = 59;
    printTime (int hour, int minute);   // WRONG!
\end{verbatim}
%
In this case, the compiler can tell the type of {\tt hour}
and {\tt minute} by looking at their declarations.  It is
unnecessary and illegal to include the type when you pass them
as arguments.  The correct
syntax is {\tt printTime (hour, minute)}.

\section {Functions with results}
\index{fruitful function}
\index{function!fruitful}

You might have noticed by now that some of the functions we are using,
like the math functions, yield results.  Other functions,
like {\tt newLine}, perform an action but
don't return a value.  That raises some questions:

\begin{itemize}

\item What happens if you call a function and you don't
do anything with the result (i.e. you don't assign it to
a variable or use it as part of a larger expression)?

\item What happens if you use a function without a result as part
of an expression, like {\tt newLine() + 7}?

\item Can we write functions that yield results, or are we
stuck with things like {\tt newLine} and {\tt printTwice}?

\end{itemize}

The answer to the third question is ``yes, you can write functions that
return values,'' and we'll do it in a couple of chapters.  I will
leave it up to you to answer the other two questions by trying them
out.  Any time you have a question about what is legal or
illegal in C++, a good way to find out is to ask the compiler.

\section{Glossary}

\begin{description}

\item[floating-point:] A type of variable (or value) that can contain
fractions as well as integers.  There are a few floating-point types
in C++; the one we use in this book is {\tt double}.

\item[initialization:]  A statement that declares a new variable
and assigns a value to it at the same time.

\item[function:]  A named sequence of statements that performs some
useful function.  Functions may or may not take parameters, and may
or may not produce a result.

\item[parameter:]  A piece of information you provide
in order to call a function.  Parameters are like variables in
the sense that they contain values and have types.

\item[argument:]  A value that you provide when you call a
function.  This value must have the same type as the corresponding
parameter.

\item[call:]  Cause a function to be executed.

\index{floating-point}
\index{function}
\index{parameter}
\index{argument}
\index{call}
\index{initialization}

\end{description}

% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.



\chapter{Conditionals and recursion}
\label{condrecursion}

\section{The modulus operator}
\index{modulus}
\index{operator!modulus}

The modulus operator works on integers (and integer expressions)
and yields the {\em remainder} when the first operand is divided
by the second.  In C++, the modulus operator is a percent sign,
{\tt \%}.  The syntax is exactly the same as for other operators:

\begin{verbatim}
  int quotient = 7 / 3;
  int remainder = 7 % 3;
\end{verbatim}
%
The first operator, integer division, yields 2.  The second
operator yields 1.  Thus, 7 divided by 3 is 2 with 1 left over.

The modulus operator turns out to be surprisingly useful.  For
example, you can check whether one number is divisible by
another: if {\tt x \% y} is zero, then {\tt x} is divisible
by {\tt y}.

Also, you can use the modulus operator to extract the rightmost
digit or digits from a number.  For example, {\tt x \% 10} yields
the rightmost digit of {\tt x} (in base 10).  Similarly
{\tt x \% 100} yields the last two digits.

\section{Conditional execution}
\index{conditional}
\index{statement!conditional}

In order to write useful programs, we almost always need the ability
to check certain conditions and change the behavior of the program
accordingly.  {\bf Conditional statements} give us this ability.  The
simplest form is the {\tt if} statement:

\begin{verbatim}
  if (x > 0) {
    cout << "x is positive" << endl;
  }
\end{verbatim}
%
The expression in parentheses is called the condition.
If it is true, then the statements in brackets get executed.
If the condition is not true, nothing happens.

\index{operator!comparison}
\index{comparison!operator}

The condition can contain any of the {\tt comparison operators}:

\begin{verbatim}
    x == y               // x equals y
    x != y               // x is not equal to y
    x > y                // x is greater than y
    x < y                // x is less than y
    x >= y               // x is greater than or equal to y
    x <= y               // x is less than or equal to y
\end{verbatim}
%
Although these operations are probably familiar to you, the
syntax C++ uses is a little different from mathematical
symbols like $=$, $\neq$ and $\le$.  A common error is
to use a single {\tt =} instead of a double {\tt ==}.  Remember
that {\tt =} is the assignment operator, and {\tt ==} is
a comparison operator.  Also, there is no such thing as
{\tt =<} or {\tt =>}.

The two sides of a condition operator have to be the same
type.  You can only compare {\tt ints} to {\tt ints} and
{\tt doubles} to {\tt doubles}.  Unfortunately, at this
point you can't compare {\tt String}s at all!  There is
a way to compare {\tt String}s, but we won't get to it for a couple
of chapters.

\section {Alternative execution}
\label{alternative}
\index{conditional!alternative}

A second form of conditional execution is alternative execution,
in which there are two possibilities, and the condition determines
which one gets executed.  The syntax looks like:

\begin{verbatim}
  if (x%2 == 0) {
    cout << "x is even" << endl;
  } else {
    cout << "x is odd" << endl;
  }
\end{verbatim}
%
If the remainder when {\tt x} is divided by 2 is zero, then
we know that {\tt x} is even, and this code displays a message
to that effect.  If the condition is false, the second
set of statements is executed.  Since the condition must
be true or false, exactly one of the alternatives will be
executed.

As an aside, if you think you might want to check the parity
(evenness or oddness) of numbers often, you might want to
``wrap'' this code up in a function, as follows:

\begin{verbatim}
void printParity (int x) {
  if (x%2 == 0) {
    cout << "x is even" << endl;
  } else {
    cout << "x is odd" << endl;
  }
}
\end{verbatim}
%
Now you have a function named {\tt printParity} that will display
an appropriate message for any integer you care to provide.
In {\tt main} you would call this function as follows:

\begin{verbatim}
    printParity (17);
\end{verbatim}
%
Always remember that when you {\em call} a function, you do
not have to declare the types of the arguments you provide.
C++ can figure out what type they are.  You should resist the
temptation to write things like:

\begin{verbatim}
  int number = 17;
  printParity (int number);         // WRONG!!!
\end{verbatim}

\section {Chained conditionals}
\index{conditional!chained}

Sometimes you want to check for a number of related conditions
and choose one of several actions.  One way to do this is by
{\bf chaining} a series of {\tt if}s and {\tt else}s:

\begin{verbatim}
  if (x > 0) {
    cout << "x is positive" << endl;
  } else if (x < 0) {
    cout << "x is negative" << endl;
  } else {
    cout << "x is zero" << endl;
  }
\end{verbatim}
%
These chains can be as long as you want, although they can
be difficult to read if they get out of hand.  One way to
make them easier to read is to use standard indentation,
as demonstrated in these examples.  If you keep all the
statements and squiggly-braces lined up, you are less
likely to make syntax errors and you can find them more
quickly if you do.

\section{Nested conditionals}
\index{conditional!nested}

In addition to chaining, you can also nest one conditional
within another.  We could have written the previous example
as:

\begin{verbatim}
  if (x == 0) {
    cout << "x is zero" << endl;
  } else {
    if (x > 0) {
      cout << "x is positive" << endl;
    } else {
      cout << "x is negative" << endl;
    }
  }
\end{verbatim}
%
There is now an outer conditional that contains two branches.  The
first branch contains a simple output statement, but the second
branch contains another {\tt if} statement, which has two branches
of its own.  Fortunately, those two branches are both output
statements, although they could have been conditional statements as
well.

Notice again that indentation helps make the structure
apparent, but nevertheless, nested conditionals get difficult to read
very quickly.  In general, it is a good idea to avoid them when you
can.

\index{nested structure}

On the other hand, this kind of {\bf nested structure} is common, and
we will see it again, so you better get used to it.

\section{The {\tt return} statement}
\index{return}
\index{statement!return}

The {\tt return} statement allows you to terminate the execution
of a function before you reach the end.  One reason to use it
is if you detect an error condition:

\begin{verbatim}
#include <cmath>

void printLogarithm (double x) {
  if (x <= 0.0) {
    cout << "Positive numbers only, please." << endl;
    return;
  }

  double result = log (x);
  cout << "The log of x is " << result;
}
\end{verbatim}
%
This defines a function named {\tt printLogarithm} that takes
a {\tt double} named {\tt x} as a parameter.  The first thing
it does is check whether {\tt x} is less than or equal to
zero, in which case it displays an error message and then uses
{\tt return} to exit the function.  The flow of execution
immediately returns to the caller and the remaining lines of
the function are not executed.

I used a floating-point value on the right side of the condition
because there is a floating-point variable on the left.

Remember that any time you want to use one a function from the math
library, you have to include the header file {\tt math.h}.

\section{Recursion}
\label{recursion}
\index{recursion}

I mentioned in the last chapter that it is legal for one function to
call another, and we have seen several examples of that.  I neglected
to mention that it is also legal for a function to call itself.  It
may not be obvious why that is a good thing, but it turns out to be
one of the most magical and interesting things a program can do.

For example, look at the following function:

\begin{verbatim}
void countdown (int n) {
  if (n == 0) {
    cout << "Blastoff!" << endl;
  } else {
    cout << n << endl;
    countdown (n-1);
  }
}
\end{verbatim}
%
The name of the function is {\tt countdown} and it takes a single
integer as a parameter.  If the parameter is zero, it outputs
the word ``Blastoff.''  Otherwise, it outputs the parameter and
then calls a function named {\tt countdown}---itself---passing
{\tt n-1} as an argument.

What happens if we call this function like this:

\begin{verbatim}
#include <iostream>
#include <cmath>
using namespace std;
void printLogarithm (double x) {
  if (x <= 0.0) {
    cout << "Positive numbers only, please." << endl;
    return;
  }

  double result = log (x);
  cout << "The log of x is " << result;
}

void countdown (int n) {
  if (n == 0) {
    cout << "Blastoff!" << endl;
  } else {
    cout << n << endl;
    countdown (n-1);
  }
}

int main ()
{
  countdown (3);
  return 0;
}
\end{verbatim}
%
The execution of {\tt countdown} begins with {\tt n=3}, and
since {\tt n} is not zero, it outputs the value 3, and then
calls itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt n=2}, and
since {\tt n} is not zero, it outputs the value 2, and then
calls itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt n=1}, and
since {\tt n} is not zero, it outputs the value 1, and then
calls itself...

\begin{quote}
The execution of {\tt countdown} begins with {\tt n=0}, and
since {\tt n} is zero, it outputs the word ``Blastoff!''
and then returns.
\end{quote}

The countdown that got {\tt n=1} returns.

\end{quote}

The countdown that got {\tt n=2} returns.

\end{quote}

The countdown that got {\tt n=3} returns.

\noindent And then you're back in {\tt main} (what a trip).  So the
total output looks like:

\begin{verbatim}
3
2
1
Blastoff!
\end{verbatim}
%
As a second example, let's look again at the functions
{\tt newLine} and {\tt threeLine}.

\begin{verbatim}
void newLine () {
  cout << endl;
}

void threeLine () {
  newLine ();  newLine ();  newLine ();
}
\end{verbatim}
%
Although these work, they would not be much help if I wanted
to output 2 newlines, or 106.  A better alternative would be

\begin{verbatim}
void nLines (int n) {
  if (n > 0) {
    cout << endl;
    nLines (n-1);
  }
}
\end{verbatim}
%
This program is similar to {\tt countdown}; as long as {\tt n} is
greater than zero, it outputs one newline, and then calls itself to
output {\tt n-1} additional newlines.  Thus, the total number of
newlines is {\tt 1 + (n-1)}, which usually comes out to roughly {\tt
n}.

\index{recursive}
\index{newline}

The process of a function calling itself is called {\bf recursion}, and
such functions are said to be {\bf recursive}.

\section {Infinite recursion}

In the examples in the previous section, notice that each time the
functions get called recursively, the argument gets smaller by one, so
eventually it gets to zero.  When the argument is zero, the function
returns immediately, {\em without making any recursive calls}.
This case---when the function completes without making a recursive
call---is called the {\bf base case}.

If a recursion never reaches a base case, it will go on making recursive
calls forever and the program will never terminate.  This is known as
{\bf infinite recursion}, and it is generally not considered a good
idea.

\index{recursion!infinite}
\index{infinite recursion}
\index{run-time error}

In most programming environments, a program with an infinite
recursion will not really run forever.  Eventually, something
will break and the program will report an error.  This is the
first example we have seen of a run-time error (an error that
does not appear until you run the program).

You should write a small program that recurses forever and run
it to see what happens.

\section {Stack diagrams for recursive functions}
\index{stack}
\index{diagram!state}
\index{diagram!stack}

In the previous chapter we used a stack diagram to represent the
state of a program during a function call.  The same kind
of diagram can make it easier to interpret a recursive function.

Remember that every time a function gets called it creates
a new instance that contains
the function's local variables and parameters.

This figure shows a stack diagram for countdown, called
with {\tt n = 3}:

\vspace{0.1in}
\centerline{\epsfig{figure=stack2.eps}}
\vspace{0.1in}
%
There is one instance of {\tt main} and four instances of
{\tt countdown}, each with a different value for the parameter
{\tt n}.  The bottom of the stack, {\tt countdown} with {\tt n=0}
is the base case.  It does not make a recursive call, so there
are no more instances of {\tt countdown}.

The instance of {\tt main} is empty because {\tt main} does not
have any parameters or local variables.  As an exercise, draw a
stack diagram for {\tt nLines}, invoked with the parameter {\tt n=4}.


\section{Glossary}

\begin{description}

\item[modulus:]  An operator that works on integers and yields
the remainder when one number is divided by another.  In C++
it is denoted with a percent sign ({\tt \%}).

\item[conditional:]  A block of statements that may or may not
be executed depending on some condition.

\item[chaining:]  A way of joining several conditional statements
in sequence.

\item[nesting:] Putting a conditional statement inside one or both
branches of another conditional statement.

\item[recursion:]  The process of calling the same function you
are currently executing.

\item[infinite recursion:]  A function that calls itself
recursively without every reaching the base case.  Eventually
an infinite recursion will cause a run-time error.

\index{modulus}
\index{conditional}
\index{conditional!chained}
\index{conditional!nested}
\index{recursion}
\index{recursion!infinite}
\index{infinite recursion}

\end{description}


% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{Fruitful functions}

\section{Return values}
\index{return}
\index{statement!return}
\index{function!fruitful}
\index{fruitful function}
\index{return value}
\index{void}
\index{function!void}

Some of the built-in functions we have used, like the math
functions, have produced results.  That is, the effect of
calling the function is to generate a new value, which we
usually assign to a variable or use as part of an expression.
For example:

\index{math function!exp}
\index{math function!sin}

\begin{verbatim}
  double e = exp (1.0);
  double height = radius * sin (angle);
\end{verbatim}
%
But so far all the functions we have written have been {\bf void}
functions; that is, functions that return no value.  When you call
a void function, it is typically on a line by itself, with
no assignment:

\begin{verbatim}
  nLines (3);
  countdown (n-1);
\end{verbatim}
%
In this chapter, we are going to write functions that return things,
which I will refer to as {\bf fruitful} functions, for want of a
better name.  The first example is {\tt area}, which takes a {\tt
double} as a parameter, and returns the area of a circle with the
given radius:

\index{math function!acos}
\index{pi}

\begin{verbatim}
double area (double radius) {
  double pi = acos (-1.0);
  double area = pi * radius * radius;
  return area;
}
\end{verbatim}
%
The first thing you should notice is that the beginning of the
function definition is different.  Instead of {\tt void}, which
indicates a void function, we see {\tt double}, which indicates that
the return value from this function will have type {\tt double}.

Also, notice that the last line is an alternate form of the
{\tt return} statement that includes a return value.  This
statement means, ``return immediately from this function and
use the following expression as a return value.''  The
expression you provide can be arbitrarily complicated,
so we could have written this function more concisely:

\begin{verbatim}
double area (double radius) {
  return acos(-1.0) * radius * radius;
}
\end{verbatim}
%
On the other hand, {\bf temporary} variables like {\tt area} often
make debugging easier.  In either case, the type of the expression in
the {\tt return} statement must match the return type of the function.
In other words, when you declare that the return type is {\tt double},
you are making a promise that this function will eventually
produce a {\tt double}.  If you try to {\tt return} with no
expression, or an expression with the wrong type, the compiler will
take you to task.

\index{temporary variable}
\index{variable!temporary}

Sometimes it is useful to have multiple return
statements, one in each branch of a conditional:

\begin{verbatim}
double absoluteValue (double x) {
  if (x < 0) {
    return -x;
  } else {
    return x;
  }
}
\end{verbatim}
%
Since these returns statements are in an alternative conditional, only
one will be executed.  Although it is legal to have more than one
{\tt return} statement in a function, you should keep in mind that as soon
as one is executed, the function terminates without executing any
subsequent statements.

Code that appears after a {\tt return} statement, or any place else
where it can never be executed, is called {\bf dead code}.  Some
compilers warn you if part of your code is dead.

\index{dead code}

If you put return statements inside a conditional, then
you have to guarantee that {\em every possible path} through
the program hits a return statement.  For example:

\begin{verbatim}
double absoluteValue (double x) {
  if (x < 0) {
    return -x;
  } else if (x > 0) {
    return x;
  }                          // WRONG!!
}
\end{verbatim}
%
This program is not correct because if {\tt x} happens to be 0, then
neither condition will be true and the function will end without hitting
a return statement.  Unfortunately, many C++ compilers do not catch
this error.  As a result, the program may compile and run, but the
return value when {\tt x==0} could be anything, and will probably
be different in different environments.

\index{absolute value}
\index{error!compile-time}
\index{compile-time error}

By now you are probably sick of seeing compiler errors, but as you
gain more experience, you will realize that the only thing worse
than getting a compiler error is {\em not} getting a compiler error
when your program is wrong.

Here's the kind of thing that's likely to happen: you test {\tt
absoluteValue} with several values of {\tt x} and it seems to work
correctly.  Then you give your program to someone else and they run it
in another environment.  It fails in some mysterious way, and it
takes days of debugging to discover that the problem is an
incorrect implementation of {\tt absoluteValue}.  If only the
compiler had warned you!

\index{compile-time error}
\index{error!compile-time}
\index{debugging}

From now on, if the compiler points out an error in your program, you
should not blame the compiler.  Rather, you should thank the compiler
for finding your error and sparing you days of debugging.  Some
compilers have an option that tells them to be extra strict and report
all the errors they can find.  You should turn this option on all the
time.

\index{math function!fabs}

As an aside, you should know that there is a function in the
math library called {\tt fabs} that calculates the absolute
value of a {\tt double}---correctly.

\section{Program development}
\label{distance}
\index{program development}

At this point you should be able to look at complete C++ functions
and tell what they do.  But it may not be clear yet how to go
about writing them.  I am going to suggest one technique that
I call {\bf incremental development}.

\index{incremental development}
\index{program development}

As an example, imagine you want to find the distance between two
points, given by the coordinates $(x_1, y_1)$ and $(x_2, y_2)$.  By
the usual definition,

\begin{equation}
distance = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\end{equation}
%
The first step is to consider what a {\tt distance} function
should look like in C++.  In other words, what are the inputs
(parameters) and what is the output (return value).

In this case, the two points are the parameters, and it is natural to
represent them using four {\tt double}s.  The return value is the
distance, which will have type {\tt double}.

Already we can write an outline of the function:

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  return 0.0;
}
\end{verbatim}
%
The {\tt return} statement is a placekeeper so that the function will
compile and return something, even though it is not the right answer.
At this stage the function doesn't do anything useful, but it is
worthwhile to try compiling it so we can identify any syntax errors
before we make it more complicated.

In order to test the new function, we have to call it with
sample values.  Somewhere in {\tt main} I would add:

\begin{verbatim}
  double dist = distance (1.0, 2.0, 4.0, 6.0);
  cout << dist << endl;
\end{verbatim}
%
I chose these values so that the horizontal
distance is 3 and the vertical distance is 4; that way,
the result will be 5 (the hypotenuse of a 3-4-5 triangle).
When you are testing a function, it is useful to know the right
answer.

Once we have checked the syntax of the function definition, we
can start adding lines of code one at a time.  After each
incremental change, we recompile and run the program.  That
way, at any point we know exactly where the error must be---in
the last line we added.

The next step in the computation is to find the differences
$x_2 - x_1$ and $y_2 - y_1$.  I will store those values in
temporary variables named {\tt dx} and {\tt dy}.

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  double dx = x2 - x1;
  double dy = y2 - y1;
  cout << "dx is " << dx << endl;
  cout << "dy is " << dy << endl;
  return 0.0;
}
\end{verbatim}
%
I added output statements that will let me check the intermediate
values before proceeding.  As I mentioned, I already know that they
should be 3.0 and 4.0.

\index{scaffolding}

When the function is finished I will remove the output statements.  Code
like that is called {\bf scaffolding}, because it is helpful for
building the program, but it is not part of the final product.
Sometimes it is a good idea to keep the scaffolding around, but
comment it out, just in case you need it later.

The next step in the development is to square {\tt dx} and {\tt dy}.
We could use the {\tt pow} function, but it is simpler and
faster to just multiply each term by itself.

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  double dx = x2 - x1;
  double dy = y2 - y1;
  double dsquared = dx*dx + dy*dy;
  cout << "dsquared is " << dsquared;
  return 0.0;
}
\end{verbatim}
%
Again, I would compile and run the program at this stage
and check the intermediate value (which should be 25.0).

Finally, we can use the {\tt sqrt} function to compute and
return the result.

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  double dx = x2 - x1;
  double dy = y2 - y1;
  double dsquared = dx*dx + dy*dy;
  double result = sqrt (dsquared);
  return result;
}
\end{verbatim}
%
Then in {\tt main}, we should output and check the value of the result.

As you gain more experience programming, you might find yourself
writing and debugging more than one line at a time.  Nevertheless,
this incremental development process can save you a lot of
debugging time.

The key aspects of the process are:

\begin{itemize}

\item Start with a working program and make small, incremental
changes.  At any point, if there is an error, you will know
exactly where it is.

\item Use temporary variables to hold intermediate values so
you can output and check them.

\item Once the program is working, you might want to remove
some of the scaffolding or consolidate multiple statements into
compound expressions, but only if it does not make the program
difficult to read.

\end{itemize}

\section{Composition}
\index{composition}

As you should expect by now, once you define a new function,
you can use it as part of an expression, and you can build
new functions using existing functions.  For example, what if someone
gave you two points, the center of the circle and a point on
the perimeter, and asked for the area of the circle?

Let's say the center point is stored in the variables {\tt xc}
and {\tt yc}, and the perimeter point is in {\tt xp} and
{\tt yp}.  The first step is to find the radius of the circle, which
is the distance between the two points.  Fortunately, we have
a function, {\tt distance}, that does that.

\begin{verbatim}
  double radius = distance (xc, yc, xp, yp);
\end{verbatim}
%
The second step is to find the area of a circle with that
radius, and return it.

\begin{verbatim}
  double result = area (radius);
  return result;
\end{verbatim}
%
Wrapping that all up in a function, we get:

\begin{verbatim}
double fred (double xc, double yc, double xp, double yp) {
  double radius = distance (xc, yc, xp, yp);
  double result = area (radius);
  return result;
} 
\end{verbatim}
%
The name of this function is {\tt fred}, which may seem odd.  I will
explain why in the next section.

The temporary variables {\tt radius} and {\tt area} are
useful for development and debugging, but once the program is
working we can make it more concise by composing
the function calls:

\begin{verbatim}
double fred (double xc, double yc, double xp, double yp) {
  return area (distance (xc, yc, xp, yp));
} 
\end{verbatim}

\section{Overloading}
\label{overloading}
\index{overloading}

In the previous section you might have noticed that {\tt fred}
and {\tt area} perform similar functions---finding
the area of a circle---but take different parameters.  For
{\tt area}, we have to provide the radius; for {\tt fred}
we provide two points.

If two functions do the same thing, it is natural to give them
the same name.  In other words, it would make more sense if
{\tt fred} were called {\tt area}.

Having more than one function with the same name, which is called {\bf
overloading}, is legal in C++ {\em as long as each version takes
different parameters}.  So we can go ahead and rename {\tt fred}:

\begin{verbatim}
double area (double xc, double yc, double xp, double yp) {
  return area (distance (xc, yc, xp, yp));
} 
\end{verbatim}
%
This looks like a recursive function, but it is not.  Actually,
this version of {\tt area} is calling the other version.
When you call an overloaded function, C++ knows which version you
want by looking at the arguments that you provide.  If you write:

\begin{verbatim}
    double x = area (3.0);
\end{verbatim}
%
C++ goes looking for a function named {\tt area} that
takes a {\tt double} as an argument, and so it uses the
first version.  If you write

\begin{verbatim}
    double x = area (1.0, 2.0, 4.0, 6.0);
\end{verbatim}
%
C++ uses the second version of {\tt area}.  

Many of the built-in C++ commands are overloaded, meaning that there
are different versions that accept different numbers or types of
parameters.

Although overloading is a useful feature, it should be used with
caution.  You might get yourself nicely confused if you are trying to
debug one version of a function while accidently calling a different
one.

Actually, that reminds me of one of the cardinal rules of debugging:
{\bf make sure that the version of the program you are looking at is
the version of the program that is running!}  Some time you may find
yourself making one change after another in your program, and seeing
the same thing every time you run it.  This is a warning sign that for
one reason or another you are not running the version of the program
you think you are.  To check, stick in an output statement (it
doesn't matter what it says) and make sure the behavior of the
program changes accordingly.

\section{Boolean values}
\index{boolean}
\index{value!boolean}

The types we have seen so far are pretty big.  There are a lot
of integers in the world, and even more floating-point numbers.
By comparison, the set of characters is pretty small.  Well, there
is another type in C++ that is even smaller.  It is called
{\bf boolean}, and the only values in it are
{\tt true} and {\tt false}.

Without thinking about it, we have been using boolean values for the
last couple of chapters.  The condition inside an {\tt if}
statement or a {\tt while} statement is a boolean expression.
Also, the result of a comparison operator is a boolean value.
For example:

\begin{verbatim}
  if (x == 5) {
    // do something
  }
\end{verbatim}
%
The operator {\tt ==} compares two integers and produces a
boolean value.

\index{operator!comparison}
\index{comparison operator}

The values {\tt true} and {\tt false} are keywords in C++,
and can be used anywhere a boolean expression is called for.
For example, 

\begin{verbatim}
  while (true) {
    // loop forever
  }
\end{verbatim}
%
is a standard idiom for a loop that should run forever (or
until it reaches a {\tt return} or {\tt break} statement).

\section{Boolean variables}
\index{type!{\tt bool}}

As usual, for every type of value, there is a corresponding
type of variable.  In C++ the boolean type is called {\bf bool}.
Boolean variables work just like the other types:

\begin{verbatim}
  bool fred;
  fred = true;
  bool testResult = false;
\end{verbatim}
%
The first line is a simple variable declaration;
the second line is an assignment, and the third line is a
combination of a declaration and as assignment, 
called an initialization.

\index{initialization}
\index{statement!initialization}

As I mentioned, the result of a comparison operator is a boolean,
so you can store it in a {\tt bool} variable

\begin{verbatim}
  bool evenFlag = (n%2 == 0);     // true if n is even
  bool positiveFlag = (x > 0);    // true if x is positive
\end{verbatim}
%
and then use it as part of a conditional statement later

\begin{verbatim}
  if (evenFlag) {
    cout << "n was even when I checked it" << endl;
  }
\end{verbatim}
%
A variable used in this way is called a {\bf flag},
since it flags the presence or absence of some condition.

\index{flag}

\section{Logical operators}
\index{logical operator}
\index{operator!logical}

There are three {\bf logical operators} in C++: AND, OR and NOT,
which are denoted by the symbols {\tt \&\&}, {\tt ||} and
{\tt !}.  The semantics (meaning) of these operators is similar
to their meaning in English.  For example {\tt x > 0 \&\& x < 10}
is true only if {\tt x} is greater than zero AND less than 10.

\index{semantics}

{\tt evenFlag || n\%3 == 0} is true if {\em either} of
the conditions is true, that is, if {\tt evenFlag} is true OR the
number is divisible by 3.

Finally, the NOT operator has the effect of negating or
inverting a bool expression, so {\tt !evenFlag} is true
if {\tt evenFlag} is false; that is, if the number is odd.

\index{nested structure}

Logical operators often provide a way to simplify nested
conditional statements.  For example, how would you write
the following code using a single conditional?

\begin{verbatim}
  if (x > 0) {
    if (x < 10) {
      cout << "x is a positive single digit." << endl;
    }
  }
\end{verbatim}

\section{Bool functions}
\label{bool}
\index{bool}
\index{function!bool}

Functions can return {\tt bool} values just like any other type,
which is often convenient for hiding complicated tests inside
functions.  For example:

\begin{verbatim}
bool isSingleDigit (int x)
{
  if (x >= 0 && x < 10) {
    return true;
  } else {
    return false;
  }
}
\end{verbatim}
%
The name of this function is {\tt isSingleDigit}.  It is common
to give boolean functions names that sound like yes/no questions.
The return type is {\tt bool}, which means that every return
statement has to provide a {\tt bool} expression.

The code itself is straightforward, although it is a bit longer than
it needs to be.  Remember that the expression {\tt x >= 0 \&\& x < 10}
has type {\tt bool}, so there is nothing wrong with returning it
directly, and avoiding the {\tt if} statement altogether:

\begin{verbatim}
bool isSingleDigit (int x)
{
  return (x >= 0 && x < 10);
}
\end{verbatim}
%
In {\tt main} you can call this function in the usual ways:

\begin{verbatim}
  cout << isSingleDigit (2) << endl;
  bool bigFlag = !isSingleDigit (17);
\end{verbatim}
%
The first line outputs the value {\tt true} because 2 is a
single-digit number.  Unfortunately, when C++ outputs {\tt bool}s, it
does not display the words {\tt true} and {\tt false}, but rather the
integers {\tt 1} and {\tt 0}.\footnote{There is a way to fix that
using the {\tt boolalpha} flag, but it is too hideous to mention.}

The second line assigns the value {\tt true} to {\tt bigFlag}
only if 17 is {\em not} a single-digit number.

The most common use of {\tt bool} functions is inside conditional
statements

\begin{verbatim}
  if (isSingleDigit (x)) {
    cout << "x is little" << endl;
  } else {
    cout << "x is big" << endl;
  }
\end{verbatim}

\section {Returning from {\tt main}}

Now that we have functions that return values, I can let you in
on a secret.  {\tt main} is not really supposed to be a {\tt void}
function.  It's supposed to return an integer:

\begin{verbatim}
int main ()
{
  return 0;
}  
\end{verbatim}
%
The usual return value from {\tt main} is 0, which indicates that
the program succeeded at whatever it was supposed to to.  If something
goes wrong, it is common to return -1, or some other value that
indicates what kind of error occurred.

Of course, you might wonder who this value gets returned to, since
we never call {\tt main} ourselves.  It turns out that when the
system executes a program, it starts by calling {\tt main}
in pretty much the same way it calls all the other functions.

There are even some parameters that are passed to {\tt main}
by the system, but we are not going to deal with them for a little
while.

\section {More recursion}
\index{recursion}
\index{language!complete}

So far we have only learned a small subset of C++, but you
might be interested to know that this subset is now
a {\bf complete} programming language, by which I
mean that anything that can be computed can be expressed in this
language.  Any program ever written could be rewritten
using only the language features we have used so far (actually, we
would need a few commands to control devices like the keyboard, mouse,
disks, etc., but that's all).

\index{Turing, Alan}

Proving that claim is a non-trivial exercise first
accomplished by Alan Turing, one of the first computer scientists
(well, some would argue that he was a mathematician, but a lot of the
early computer scientists started as mathematicians).  Accordingly, it
is known as the Turing thesis.  If you take a course on the Theory of
Computation, you will have a chance to see the proof.

To give you an idea of what you can do with the tools we have learned
so far, we'll evaluate a few recursively-defined
mathematical functions.  A recursive definition is similar to a
circular definition, in the sense that the definition contains a
reference to the thing being defined.  A truly circular definition is
typically not very useful:

\begin{description}

\item[frabjuous:] an adjective used to describe
something that is frabjuous.

\index{frabjuous}

\end{description}

If you saw that definition in the dictionary, you might be
annoyed.  On the other hand, if you looked up the definition
of the mathematical function {\bf factorial}, you might
get something like:

\begin{eqnarray*}
&&  0! = 1 \\
&&  n! = n \cdot (n-1)!
\end{eqnarray*}

(Factorial is usually denoted with the symbol $!$, which is
not to be confused with the C++ logical operator {\tt !} which
means NOT.)  This definition says that the factorial of 0 is 1,
and the factorial of any other value, $n$, is $n$ multiplied
by the factorial of $n-1$.  So $3!$ is 3 times $2!$, which is 2 times
$1!$, which is 1 times 0!.  Putting it all together, we get
$3!$ equal to 3 times 2 times 1 times 1, which is 6.

If you can write a recursive definition of something, you can usually
write a C++ program to evaluate it.  The first step is to decide what
the parameters are for this function, and what the return type is.
With a little thought, you should conclude that factorial takes an
integer as a parameter and returns an integer:

\begin{verbatim}
int factorial (int n)
{
}
\end{verbatim}
%
If the argument happens to be zero, all we have to do is
return 1:

\begin{verbatim}
int factorial (int n)
{
  if (n == 0) {
    return 1;
  }
}
\end{verbatim}
%
Otherwise, and this is the interesting part, we have to make
a recursive call to find the factorial of $n-1$, and then
multiply it by $n$.

\begin{verbatim}
int factorial (int n)
{
  if (n == 0) {
    return 1;
  } else {
    int recurse = factorial (n-1);
    int result = n * recurse;
    return result;
  }
}
\end{verbatim}
%
If we look at the flow of execution for this program,
it is similar to {\tt nLines} from the previous chapter.
If we call {\tt factorial} with the value 3:

Since 3 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 2 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 1 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 0 {\em is} zero, we take the first branch and return
the value 1 immediately without making any more recursive
calls.

\end{quote}

The return value (1) gets multiplied by {\tt n}, which is 1,
and the result is returned.

\end{quote}

The return value (1) gets multiplied by {\tt n}, which is 2,
and the result is returned.

\end{quote}

\noindent The return value (2) gets multiplied by {\tt n}, which is 3,
and the result, 6, is returned to {\tt main}, or whoever
called {\tt factorial (3)}.

\index{stack}
\index{diagram!state}
\index{diagram!stack}

Here is what the stack diagram looks like for this sequence of
function calls:

\vspace{0.1in}
\centerline{\epsfig{figure=stack3.eps}}
\vspace{0.1in}
%
The return values are shown being passed back up the stack.

Notice that in the last instance of {\tt factorial}, the local
variables {\tt recurse} and {\tt result} do not exist because
when {\tt n=0} the branch that creates them does not execute.

\section{Leap of faith}
\index{leap of faith}

Following the flow of execution is one way to read programs, but as
you saw in the previous section, it can quickly become labarynthine.
An alternative is what I call the ``leap of faith.''  When you come to
a function call, instead of following the flow of execution, you
{\em assume} that the function works correctly and returns the
appropriate value.

In fact, you are already practicing this leap of faith
when you use built-in functions.  When you call {\tt cos}
or {\tt exp}, you don't examine the implementations of 
those functions.  You just assume that they work, because the people
who wrote the built-in libraries were good programmers.

Well, the same is true when you call one of your own functions.
For example, in Section~\ref{bool} we wrote a function called
{\tt isSingleDigit} that determines whether a number is between
0 and 9.  Once we have convinced ourselves that this function
is correct---by testing and examination of the code---we can
use the function without ever looking at the code again.

The same is true of recursive programs.  When you get to the recursive
call, instead of following the flow of execution, you should {\em
assume} that the recursive call works (yields the correct result), and
then ask yourself, ``Assuming that I can find the factorial of $n-1$,
can I compute the factorial of $n$?''  In this case, it is clear that
you can, by multiplying by $n$.

Of course, it is a bit strange to assume that the function works
correctly when you have not even finished writing it, but that's why
it's called a leap of faith!

\section{One more example}
\index{factorial}

In the previous example I used temporary variables to spell out the
steps, and to make the code easier to debug, but I could have saved a
few lines:

\begin{verbatim}
int factorial (int n) {
  if (n == 0) {
    return 1;
  } else {
    return n * factorial (n-1);
  }
}
\end{verbatim}
%
From now on I will tend to use the more concise version, but
I recommend that you use the more explicit version while you
are developing code.   When you have it working, you can
tighten it up, if you are feeling inspired.

After {\tt factorial}, the classic example of a recursively-defined
mathematical function is {\tt fibonacci}, which has the
following definition:

\begin{eqnarray*}
&& fibonacci(0) = 1 \\
&& fibonacci(1) = 1 \\
&& fibonacci(n) = fibonacci(n-1) + fibonacci(n-2);
\end{eqnarray*}
%
Translated into C++, this is

\begin{verbatim}
int fibonacci (int n) {
  if (n == 0 || n == 1) {
    return 1;
  } else {
    return fibonacci (n-1) + fibonacci (n-2);
  }
}
\end{verbatim}
%
If you try to follow the flow of execution here, even for fairly small
values of {\tt n}, your head explodes.  But according to the leap of
faith, if we assume that the two recursive calls (yes, you can make
two recursive calls) work correctly, then it is clear that we get the
right result by adding them together.

\section{Glossary}

\begin{description}

\item[return type:]  The type of value a function returns.

\item[return value:]  The value provided as the result of a function
call.

\item[dead code:]  Part of a program that can never be executed,
often because it appears after a {\tt return} statement.

\item[scaffolding:]  Code that is used during program development
but is not part of the final version.

\item[void:]  A special return type that indicates a void function;
that is, one that does not return a value.

\item[overloading:]  Having more than one function with the same name
but different parameters.  When you call an overloaded function,
C++ knows which version to use by looking at the arguments you
provide.

\item[boolean:]  A value or variable that can take on one of
two states, often called $true$ and $false$.  In C++, boolean
values can be stored in a variable type called {\tt bool}.

\item[flag:]  A variable (usually type {\tt bool}) that records
a condition or status information.

\item[comparison operator:]  An operator that compares two values
and produces a boolean that indicates the relationship between the
operands.

\item[logical operator:]  An operator that combines boolean values
in order to test compound conditions.

\index{return type}
\index{return value}
\index{dead code}
\index{scaffolding}
\index{void}
\index{overloading}
\index{bool}
\index{operator!conditional}
\index{operator!logical}

\end{description}

% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{Iteration}

\section{Multiple assignment}
\index{assignment}
\index{statement!assignment}
\index{multiple assignment}

I haven't said much about it, but it is legal in C++ to
make more than one assignment to the same variable.  The
effect of the second assignment is to replace the old value
of the variable with a new value.

\begin{verbatim}
  int fred = 5;
  cout << fred;
  fred = 7;
  cout << fred;
\end{verbatim}
%
The output of this program is {\tt 57}, because the first
time we print {\tt fred} his value is 5, and the second time
his value is 7.

This kind of {\bf multiple assignment} is the reason I
described variables as a {\em container} for values.  When
you assign a value to a variable, you change the contents of
the container, as shown in the figure:

\vspace{0.1in}
\centerline{\epsfig{figure=assign2.eps}}
\vspace{0.1in}

When there are multiple assignments to a variable, it is especially
important to distinguish between an assignment statement and a
statement of equality.  Because C++ uses the {\tt =} symbol for
assignment, it is tempting to interpret a statement like {\tt a = b}
as a statement of equality.  It is not!

First of all, equality is commutative, and assignment is not.
For example, in mathematics if $a = 7$ then $7 = a$.  But in
C++ the statement {\tt a = 7;} is legal, and {\tt 7 = a;}
is not.

Furthermore, in mathematics, a statement of equality is true
for all time.  If $a = b$ now, then $a$ will always equal $b$.
In C++, an assignment statement can make two variables equal,
but they don't have to stay that way!

\begin{verbatim}
  int a = 5;
  int b = a;     // a and b are now equal
  a = 3;         // a and b are no longer equal
\end{verbatim}
%
The third line changes the value of {\tt a} but it does not
change the value of {\tt b}, and so they are no longer equal.
In many programming languages an alternate symbol is used
for assignment, such as {\tt <-} or {\tt :=}, in order to
avoid confusion.

Although multiple assignment is frequently useful, you should
use it with caution.  If the values of variables are changing
constantly in different parts of the program, it can make
the code difficult to read and debug.

\section{Iteration}
\index{iteration}

One of the things computers are often used for is the automation
of repetitive tasks.  Repeating identical or similar tasks without
making errors is something that computers do well and people do
poorly.

We have seen programs that use recursion to perform
repetition, such as {\tt nLines} and {\tt countdown}.  This
type of repetition is called {\bf iteration}, and C++ provides
several language features that make it easier to write iterative
programs.

The two features we are going to look at are the {\tt while}
statement and the {\tt for} statement.

\section{The {\tt while} statement}
\index{statement!while}
\index{while statement}

Using a {\tt while} statement, we can rewrite {\tt countdown}:

\begin{verbatim}
int countdown (int n) {
  while (n > 0) {
    cout << n << endl;
    n = n-1;
  }
  cout << "Blastoff!" << endl;
  return 0;
}
\end{verbatim}
%
You can almost read a {\tt while} statement as if it were
English.  What this means is, ``While {\tt n} is greater than
zero, continue displaying the value of {\tt n} and then reducing
the value of {\tt n} by 1.  When you get to zero, output the
word `Blastoff!'''

More formally, the flow of execution for a {\tt while} statement
is as follows:

\begin{enumerate}

\item Evaluate the condition in parentheses, yielding {\tt true}
or {\tt false}.

\item If the condition is false, exit the {\tt while} statement
and continue execution at the next statement.

\item If the condition is true, execute each of the statements
between the squiggly-braces, and then go back to step 1.

\end{enumerate}

This type of flow is called a {\bf loop} because the third step loops
back around to the top.  Notice that if the condition is false the
first time through the loop, the statements inside the loop are
never executed.  The statements inside the loop are called
the {\bf body} of the loop.

\index{loop}
\index{loop!body}
\index{loop!infinite}
\index{body!loop}
\index{infinite loop}

The body of the loop should change the value of
one or more variables so that, eventually, the condition becomes
false and the loop terminates.  Otherwise the loop will repeat
forever, which is called an {\bf infinite loop}.  An endless
source of amusement for computer scientists is the observation
that the directions on shampoo, ``Lather, rinse, repeat,'' are
an infinite loop.

In the case of {\tt countdown}, we can prove that the loop
will terminate because we know that the value of {\tt n} is
finite, and we can see that the value of {\tt n} gets smaller
each time through the loop (each {\bf iteration}), so
eventually we have to get to zero.  In other cases it is not
so easy to tell:

\begin{verbatim}
  void sequence (int n) {
    while (n != 1) {
      cout << n << endl;
      if (n%2 == 0) {           // n is even
        n = n / 2;
      } else {                  // n is odd
        n = n*3 + 1;
      }
    }
  }
\end{verbatim}
%
The condition for this loop is {\tt n != 1}, so the loop
will continue until {\tt n} is 1, which will make the condition
false.

At each iteration, the program outputs the value of {\tt n} and then
checks whether it is even or odd.  If it is even, the value of
{\tt n} is divided by two.  If it is odd, the value is replaced
by $3n+1$.  For example, if the starting value (the argument passed
to {\tt sequence}) is 3, the resulting sequence is
3, 10, 5, 16, 8, 4, 2, 1.

Since {\tt n} sometimes increases and sometimes decreases, there is no
obvious proof that {\tt n} will ever reach 1, or that the program will
terminate.  For some particular values of {\tt n}, we can prove
termination.  For example, if the starting value is a power of two, then
the value of {\tt n} will be even every time through the loop, until
we get to 1.  The previous example ends with such a sequence,
starting with 16.

Particular values aside, the interesting question is whether
we can prove that this program terminates for {\em all} values of n.
So far, no one has been able to prove it {\em or} disprove it!

\section{Tables}
\index{table}
\index{logarithm}

One of the things loops are good for is generating
tabular data.  For example, before computers were readily available,
people had to calculate logarithms, sines and cosines, and other
common mathematical functions by hand.
To make that easier, there were books containing long tables
where you could find the values of various functions.
Creating these tables was slow and boring, and the result
tended to be full of errors.

When computers appeared on the scene, one of the initial reactions
was, ``This is great!  We can use the computers to generate the
tables, so there will be no errors.''  That turned out to be true
(mostly), but shortsighted.  Soon thereafter computers and
calculators were so pervasive that the tables became obsolete.

Well, almost.  It turns out that for some operations, computers
use tables of values to get an approximate answer, and then
perform computations to improve the approximation.  In some
cases, there have been errors in the underlying tables, most
famously in the table the original Intel Pentium used to perform
floating-point division.

\index{division!floating-point}

Although a ``log table'' is not as useful as it once was, it still
makes a good example of iteration.  The following program outputs a
sequence of values in the left column and their logarithms in the
right column:

\begin{verbatim}
  double x = 1.0;
  while (x < 10.0) {
    cout << x << "\t" << log(x) << "\n";
    x = x + 1.0;
  }
\end{verbatim}
%
The sequence \verb+\t+ represents a {\bf tab} character.
The
sequence \verb+\n+ represents a newline character.  These sequences
can be included anywhere in a string, although in these examples
the sequence is the whole string.

A tab character causes the cursor to shift to the right until
it reaches one of the {\bf tab stops}, which are normally every
eight characters.  As we will see in a minute, tabs are useful
for making columns of text line up.

A newline character has exactly the same effect as {\tt endl};
it causes the cursor to move on to the next line.  Usually if
a newline character appears by itself, I use {\tt endl}, but
if it appears as part of a string, I use \verb+\n+.

The output of this program is

\begin{verbatim}
1      0
2      0.693147
3      1.09861
4      1.38629
5      1.60944
6      1.79176
7      1.94591
8      2.07944
9      2.19722
\end{verbatim}
%
If these values seem odd, remember that the {\tt log} function uses
base $e$.  Since powers of two are so important in computer science,
we often want to find logarithms with respect to base 2.  To do that,
we can use the following formula:

\[ \log_2 x = \frac {log_e x}{log_e 2} \]
%
Changing the output statement to

\begin{verbatim}
      cout << x << "\t" << log(x) / log(2.0) << endl;
\end{verbatim}
%
yields

\begin{verbatim}
1      0
2      1
3      1.58496
4      2
5      2.32193
6      2.58496
7      2.80735
8      3
9      3.16993
\end{verbatim}
%
We can see that 1, 2, 4 and 8 are powers of two, because
their logarithms base 2 are round numbers.  If we wanted to find
the logarithms of other powers of two, we could modify the
program like this:

\begin{verbatim}
  double x = 1.0;
  while (x < 100.0) {
    cout << x << "\t" << log(x) / log(2.0) << endl;
    x = x * 2.0;
  }
\end{verbatim}
%
Now instead of adding something to {\tt x} each time through
the loop, which yields an arithmetic sequence, we multiply
{\tt x} by something, yielding a {\bf geometric} sequence.
The result is:

\begin{verbatim}
1      0
2      1
4      2
8      3
16     4
32     5
64     6
\end{verbatim}
%
Because we are using tab characters between the columns, the
position of the second column does not depend on the number
of digits in the first column.

Log tables may not be useful any more, but for computer scientists,
knowing the powers of two is!  As an exercise, modify this program
so that it outputs the powers of two up to 65536
(that's $2^{16}$).  Print it out and memorize it.

\section{Two-dimensional tables}
\index{table!two-dimensional}

A two-dimensional table is a table where you choose a row and
a column and read the value at the intersection.  A multiplication
table is a good example.  Let's say you wanted to print a
multiplication table for the values from 1 to 6.

A good way to start is to write a simple loop that prints
the multiples of 2, all on one line.

\begin{verbatim}
  int i = 1;
  while (i <= 6) {
    cout << 2*i << "   ";
    i = i + 1;
  }
  cout << endl;
\end{verbatim}
%
The first line initializes a variable named {\tt i}, which is
going to act as a counter, or {\bf loop variable}.  As the
loop executes, the value of {\tt i} increases from 1 to 6,
and then when {\tt i} is 7, the loop terminates.  Each
time through the loop, we print the value {\tt 2*i} followed
by three spaces.  By omitting the {\tt endl} from the
first output statement, we get 
all the output on a single line.

\index{loop variable}
\index{variable!loop}

The output of this program is:

\begin{verbatim}
2   4   6   8   10   12
\end{verbatim}
%
So far, so good.  The next step is to {\bf encapsulate} and {\bf
generalize}.

\section {Encapsulation and generalization}

Encapsulation usually means taking a piece of code and wrapping it up
in a function, allowing you to take advantage of all the things functions
are good for.  We have seen two examples of encapsulation, when we
wrote {\tt printParity} in Section~\ref{alternative} and {\tt
isSingleDigit} in Section~\ref{bool}.

Generalization means taking something specific, like printing
multiples of 2, and making it more general, like printing the
multiples of any integer.

\index{encapsulation}
\index{generalization}

Here's a function that encapsulates the loop from the previous
section and generalizes it to print multiples of {\tt n}.

\begin{verbatim}
void printMultiples (int n)
{
  int i = 1;
  while (i <= 6) {
    cout << n*i << "   ";
    i = i + 1;
  }
  cout << endl;
}
\end{verbatim}
%
To encapsulate, all I had to do was add the first line,
which declares the name, parameter,
and return type.  To generalize, all I had to do was replace
the value 2 with the parameter {\tt n}.

If we call this function with the argument 2, we get the same
output as before.  With argument 3, the output is:

\begin{verbatim}
3   6   9   12   15   18
\end{verbatim}
%
and with argument 4, the output is

\begin{verbatim}
4   8   12   16   20   24 
\end{verbatim}
%
By now you can probably guess how we are going to print a
multiplication table: we'll call {\tt printMultiples} repeatedly with
different arguments.  In fact, we are going to use another loop to
iterate through the rows.

\begin{verbatim}
  int i = 1;
  while (i <= 6) {
    printMultiples (i);
    i = i + 1;
  }    
\end{verbatim}
%
First of all, notice how similar this loop is to the one inside {\tt
printMultiples}.  All I did was replace the print statement with a
function call.

The output of this program is

\begin{verbatim}
1   2   3   4   5   6   
2   4   6   8   10   12   
3   6   9   12   15   18   
4   8   12   16   20   24   
5   10   15   20   25   30   
6   12   18   24   30   36   
\end{verbatim}
%
which is a (slightly sloppy) multiplication table.  If the
sloppiness bothers you, try replacing the spaces between
columns with tab characters and see what you get.

\section{Functions}
\index{function}

In the last section I mentioned ``all the things functions
are good for.''  About this time, you might be wondering
what exactly those things are.  Here are some of the reasons
functions are useful:

\begin{itemize}

\item By giving a name to a sequence of statements, you make
your program easier to read and debug.

\item Dividing a long program into functions allows you to
separate parts of the program, debug them in isolation, and
then compose them into a whole.

\item Functions facilitate both recursion and iteration.

\item Well-designed functions are often useful for many programs.
Once you write and debug one, you can reuse it.

\end{itemize}

\section{More encapsulation}
\index{encapsulation}
\index{program development!encapsulation}

To demonstrate encapsulation again, I'll take the code
from the previous section and wrap it up in a function:

\begin{verbatim}
void printMultTable () {
  int i = 1;
  while (i <= 6) {
    printMultiples (i);
    i = i + 1;
  }
}
\end{verbatim}
%
The process I am demonstrating is a common 
development plan.  You develop code gradually by adding
lines to {\tt main} or someplace else, and then when you get
it working, you extract it and wrap it up in a function.

The reason this is useful is that you sometimes don't know
when you start writing exactly how to divide the program into
functions.  This approach lets you design as you go along.

\section{Local variables}

About this time, you might be wondering how we can use the same
variable {\tt i} in both {\tt printMultiples} and {\tt
printMultTable}.  Didn't I say that you can only declare a variable
once?  And doesn't it cause problems when one of the functions changes
the value of the variable?

The answer to both questions is ``no,'' because the {\tt i} in {\tt
printMultiples} and the {\tt i} in {\tt printMultTable} are
{\em not the same variable}.  They have the same name, but
they do not refer to the same storage location, and changing
the value of one of them has no effect on the other.

\index{local variable}
\index{variable!local}

Remember that variables that are declared inside a function definition
are local.  You cannot access a local variable from outside its
``home'' function, and you are free to have multiple variables with
the same name, as long as they are not in the same function.

The stack diagram for this program shows clearly that the
two variables named {\tt i} are not in the same storage location.
They can have different values, and changing one does not affect
the other.

\vspace{0.1in}
\centerline{\epsfig{figure=stack4.eps}}
\vspace{0.1in}
%
Notice that the value of the parameter {\tt n} in
{\tt printMultiples} has to be the same as the value
of {\tt i} in {\tt printMultTable}.  On the other hand,
the value of {\tt i} in {\tt printMultiple} goes
from 1 up to {\tt n}.  In the diagram, it happens to be 3.
The next time through the loop it will be 4.

It is often a good idea to use different variable names in
different functions, to avoid confusion, but there are good
reasons to reuse names.  For example, it is common to
use the names {\tt i}, {\tt j} and {\tt k} as loop variables.
If you avoid using them in one function just because you
used them somewhere else, you will probably make the program
harder to read.

\index{loop variable}
\index{variable!loop}

\section{More generalization}
\index{generalization}

As another example of generalization, imagine you wanted
a program that would print a multiplication table of any
size, not just the 6x6 table.  You could add a parameter to
{\tt printMultTable}:

\begin{verbatim}
void printMultTable (int high) {
  int i = 1;
  while (i <= high) {
    printMultiples (i);
    i = i + 1;
  }
}
\end{verbatim}
%
I replaced the value 6 with the parameter {\tt high}.  If I
call {\tt printMultTable} with the argument 7, I get

\begin{verbatim}
1   2   3   4   5   6   
2   4   6   8   10   12   
3   6   9   12   15   18   
4   8   12   16   20   24   
5   10   15   20   25   30   
6   12   18   24   30   36   
7   14   21   28   35   42   
\end{verbatim}
%
which is fine, except that I probably want the table to
be square (same number of rows and columns), which means
I have to add another parameter to {\tt printMultiples},
to specify how many columns the table should have.

Just to be annoying, I will also call this parameter {\tt high},
demonstrating that different functions can have parameters
with the same name (just like local variables):

\begin{verbatim}
void printMultiples (int n, int high) {
  int i = 1;
  while (i <= high) {
    cout << n*i << "   ";
    i = i + 1;
  }    
  cout << endl;
}

void printMultTable (int high) {
  int i = 1;
  while (i <= high) {
    printMultiples (i, high);
    i = i + 1;
  }
}
\end{verbatim}
%
Notice that when I added a new parameter, I had to change the first
line of the function (the interface or prototype), and I also had to
change the place where the function is called in {\tt printMultTable}.
As expected, this program generates a square 7x7 table:

\begin{verbatim}
1   2   3   4   5   6   7   
2   4   6   8   10   12   14   
3   6   9   12   15   18   21   
4   8   12   16   20   24   28   
5   10   15   20   25   30   35   
6   12   18   24   30   36   42   
7   14   21   28   35   42   49
\end{verbatim}
%
When you generalize a function appropriately, you often find
that the resulting program has capabilities you did not intend.
For example, you might notice that the multiplication table
is symmetric, because $ab = ba$, so all the entries in the
table appear twice.  You could save ink by printing only
half the table.  To do that, you only have to change one
line of {\tt printMultTable}.  Change

\begin{verbatim}
      printMultiples (i, high);
\end{verbatim}
%
to

\begin{verbatim}
      printMultiples (i, i);
\end{verbatim}
%
and you get

\begin{verbatim}
1   
2   4   
3   6   9   
4   8   12   16   
5   10   15   20   25   
6   12   18   24   30   36   
7   14   21   28   35   42   49  
\end{verbatim}
%
I'll leave it up to you to figure out how it works.

\section{Glossary}

\begin{description}

\item[loop:]  A statement that executes repeatedly while a
condition is true or until some condition is satisfied.

\item[infinite loop:]  A loop whose condition is always true.

\item[body:]  The statements inside the loop.

\item[iteration:]  One pass through (execution of) the body
of the loop, including the evaluation of the condition.

\item[tab:] A special character, written as \verb+\t+ in C++,
that causes the cursor to move to the next tab stop on the
current line.

\item[encapsulate:]  To divide a large complex program into
components (like functions) and isolate the components from
each other (for example, by using local variables).

\item[local variable:]  A variable that is declared inside
a function and that exists only within that function.  Local variables
cannot be accessed from outside their home function, and do not
interfere with any other functions.

\item[generalize:]  To replace something unnecessarily specific
(like a constant value) with something appropriately general
(like a variable or parameter).  Generalization makes code more
versatile, more likely to be reused, and sometimes even easier
to write.

\item[development plan:]  A process for developing a program.
In this chapter, I demonstrated a style of development based on
developing code to do simple, specific things, and then encapsulating
and generalizing.

\index{loop}
\index{infinite loop}
\index{body}
\index{tab}
\index{loop!infinite}
\index{iteration}
\index{encapsulation}
\index{generalization}
\index{local variable}
\index{variable!local}
\index{program development}

\end{description}

% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{Strings and things}
\label{strings}

\section{Containers for strings}

We have seen five types of values---booleans, characters, integers,
floating-point numbers and strings---but only four types of
variables---{\tt bool}, {\tt char}, {\tt int} and {\tt double}.  So
far we have no way to store a string in a variable or perform
operations on strings.

In fact, there are several kinds of variables in C++ that
can store strings.  One is a basic type that is part of the C++
language, sometimes called ``a native C string.''  The syntax
for C strings is a bit ugly, and using them requires some concepts
we have not covered yet, so for the most part we are going to
avoid them.

The string type we are going to use is called {\tt string}, which is
one of the classes that belong to the C++ Standard Library.\footnote{You might be wondering what I mean by {\bf class}.It will be a few
more chapters before I can give a complete definition, but for now a
class is a collection of functions that defines the operations we
can perform on some type.  The {\tt string} class contains all
the functions that apply to {\tt string}s.}

Unfortunately, it is not possible to avoid C strings altogether.
In a few places in this chapter I will warn you about some problems
you might run into using {\tt string}s instead of C strings.

\section{{\tt string} variables}

You can create a variable with type {\tt string} in the usual
ways:

\begin{verbatim}
  string first;
  first = "Hello, ";
  string second = "world.";
\end{verbatim}
%
The first line creates an {\tt string} without giving it a value.
The second line assigns it the string value {\tt "Hello."}
The third line is a combined declaration and assignment, also
called an initialization.

Normally when string values like {\tt "Hello, "} or {\tt "world."}
appear, they are treated as C strings.  In this case, when we assign
them to an {\tt string} variable, they are converted automatically
to {\tt string} values.

We can output strings in the usual way:

\begin{verbatim}
  cout << first << second << endl;
\end{verbatim}
%

In order to compile this code, you will have to include the
header file for the {\tt string} class, and you will have
to add the file {\tt string} to the list of files you
want to compile.  The details of how to do this depend on your
programming environment.

Before proceeding, you should type in the program above and make
sure you can compile and run it.

\section{Extracting characters from a string}

Strings are called ``strings'' because they are made up of a sequence,
or string, of characters.  The first operation we are going to
perform on a string is to extract one of the characters.  C++
uses square brackets ({\tt [} and {\tt ]}) for this operation:

\begin{verbatim}
  string fruit = "banana";
  char letter = fruit[1];
  cout << letter << endl;
\end{verbatim}
%
The expression {\tt fruit[1]} indicates that I want character number 1
from the string named {\tt fruit}.  The result is stored in a {\tt
char} named {\tt letter}.  When I output the value of {\tt letter}, I
get a surprise:

\begin{verbatim}
a
\end{verbatim}
%
{\tt a} is not the first letter of {\tt "banana"}.  Unless you are a
computer scientist.  For perverse reasons, computer scientists always
start counting from zero.  The 0th letter (``zeroeth'') of {\tt
"banana"} is {\tt b}.  The 1th letter (``oneth'') is {\tt a} and the
2th (``twoeth'') letter is {\tt n}.

If you want the the zereoth letter of a string, you have to put
zero in the square brackets:

\begin{verbatim}
  char letter = fruit[0];
\end{verbatim}

\section{Length}
\index{string!length}
\index{length!string}

To find the length of a string (number of characters), we can
use the {\tt length} function.  The syntax for calling this
function is a little different from what we've seen before:

\begin{verbatim}
  int length;
  length = fruit.length();
\end{verbatim}
%
To describe this function call, we would say that we are {\bf
invoking} the length function on the string named {\tt fruit}.  This
vocabulary may seem strange, but we will see many more examples where
we invoke a function on an object.  The syntax for function invocation
is called ``dot notation,'' because the dot (period) separates the
name of the object, {\tt fruit}, from the name of the function, {\tt
length}.

{\tt length} takes no arguments, as indicated by the empty parentheses
{\tt ()}.  The return value is an integer, in this case 6.  Notice
that it is legal to have a variable with the same name as a function.

To find the last letter of a string, you might be tempted to
try something like

\begin{verbatim}
  int length = fruit.length();
  char last = fruit[length];       // WRONG!!
\end{verbatim}
%
That won't work.  The reason is that there is no 6th letter
in {\tt "banana"}.  Since we started counting at 0, the 6
letters are numbered from 0 to 5.  To get the last character,
you have to subtract 1 from {\tt length}.

\begin{verbatim}
  int length = fruit.length();
  char last = fruit[length-1];
\end{verbatim}

\section{Traversal}
\index{traverse}

A common thing to do with a string is
start at the beginning, select each character in turn, do
something to it, and continue until the end.  This pattern
of processing is called a {\bf traversal}.  A natural
way to encode a traversal is with a {\tt while} statement:

\begin{verbatim}
  int index = 0;
  while (index < fruit.length()) {
    char letter = fruit[index];
    cout << letter << endl;
    index = index + 1;
  }
\end{verbatim}
%
This loop traverses the string and outputs each letter on
a line by itself.  Notice that the condition is
{\tt index < fruit.length()}, which means that when
{\tt index} is equal to the length of the string, the
condition is false and the body of the loop is not executed.
The last character we access is the one with the
index {\tt fruit.length()-1}.

\index{loop variable}
\index{variable!loop}
\index{index}

The name of the loop variable is {\tt index}.  An {\bf
index} is a variable or value used to specify one member of an ordered
set, in this case the set of characters in the string.  The index
indicates (hence the name) which one you want.  The set has to be
ordered so that each letter has an index and each index
refers to a single character.

As an exercise, write a function that takes an {\tt string}
as an argument and that outputs the letters backwards, all on
one line.

\section{A run-time error}
\index{error!run-time}
\index{run-time error}

Way back in Section~\ref{run-time} I talked about run-time errors,
which are errors that don't appear until a program has started
running.

So far, you probably haven't seen many run-time errors, because we
haven't been doing many things that can cause one.  Well, now we are.
If you use the {\tt []} operator and you provide an index that is
negative or greater than {\tt length-1}, you will get a run-time
error and a message something like this:

\begin{verbatim}
index out of range: 6, string: banana
\end{verbatim}
%
Try it in your development environment and see how it looks.

\section{The {\tt find} function}
\index{find}

The {\tt string} class provides several other functions that you can
invoke on strings.  The {\tt find} function is like the opposite the
{\tt []} operator.  Instead of taking an index and extracting the
character at that index, {\tt find} takes a character and finds the
index where that character appears.

\begin{verbatim}
  string fruit = "banana";
  int index = fruit.find('a');
\end{verbatim}
%
This example finds the index of the letter {\tt 'a'} in the string.
In this case, the letter appears three times, so it is not obvious
what {\tt find} should do.  According to the documentation, it returns
the index of the {\em first} appearance, so the result is 1.  If the
given letter does not appear in the string, {\tt find} returns -1.

In addition, there is a
version of {\tt find} that takes another {\tt string} as
an argument and that finds the index where the substring
appears in the string.  For example,

\begin{verbatim}
  string fruit = "banana";
  int index = fruit.find("nan");
\end{verbatim}
%
This example returns the value 2.

You should remember from Section~\ref{overloading} that there
can be more than one function with the same name, as long as they
take a different number of parameters or different types.  In
this case, C++ knows which version of {\tt find} to invoke
by looking at the type of the argument we provide.

\section{Our own version of {\tt find}}

If we are looking for a letter in an {\tt string}, we may
not want to start at the beginning of the string.  One way
to generalize the {\tt find} function is to write a version
that takes an additional parameter---the index where we should
start looking.  Here is an implementation of this function.

\begin{verbatim}
int find (string s, char c, int i)
{
  while (i<s.length()) {
    if (s[i] == c) return i;
    i = i + 1;
  }
  return -1;
}
\end{verbatim}
%
Instead of invoking this function on an {\tt string}, like
the first version of {\tt find}, we have to pass the {\tt string}
as the first argument.  The other arguments are the character
we are looking for and the index where we should start.

\section{Looping and counting}
\label{loopcount}
\index{traverse!counting}
\index{loop!counting}

The following program counts the
number of times the letter {\tt 'a'} appears in a string:

\begin{verbatim}
  string fruit = "banana";
  int length = fruit.length();
  int count = 0;

  int index = 0;
  while (index < length) {
    if (fruit[index] == 'a') {
      count = count + 1;
    }
    index = index + 1;
  }
  cout << count << endl;
\end{verbatim}
%
This program demonstrates a common idiom, called a {\bf counter}.  The
variable {\tt count} is initialized to zero and then incremented each
time we find an {\tt 'a'}.  (To {\bf increment} is to increase by one;
it is the opposite of {\bf decrement}, and unrelated to {\bf
excrement}, which is a noun.)  When we exit the loop, {\tt count}
contains the result: the total number of a's.

\index{counter}
\index{increment}
\index{decrement}

As an exercise, encapsulate this code in a function named
{\tt countLetters}, and generalize it so that it accepts the
string and the letter as arguments.

\index{encapsulation}
\index{generalization}

As a second exercise, rewrite this function so that instead
of traversing the string, it uses the version of
{\tt find} we wrote in the previous section.

\section{Increment and decrement operators}
\index{operator!increment}
\index{operator!decrement}

Incrementing and decrementing are such common operations that C++
provides special operators for them.  The {\tt ++} operator adds one
to the current value of an {\tt int}, {\tt char} or {\tt double}, and
{\tt --} subtracts one.  Neither operator works on {\tt string}s,
and neither {\em should} be used on {\tt bool}s.

Technically, it is legal to increment a variable and use it
in an expression at the same time.  For example, you might see
something like:

\begin{verbatim}
  cout << i++ << endl;
\end{verbatim}
%
Looking at this, it is not clear whether the increment will
take effect before or after the value is displayed.  Because
expressions like this tend to be confusing, I would discourage
you from using them.  In fact, to discourage you even more,
I'm not going to tell you what the result is.  If you really
want to know, you can try it.

Using the increment operators, we can rewrite the letter-counter:

\begin{verbatim}
  int index = 0;
  while (index < length) {
    if (fruit[index] == 'a') {
      count++;
    }
    index++;
  }
\end{verbatim}
%
It is a common error to write something like

\begin{verbatim}
  index = index++;             // WRONG!!
\end{verbatim}
%
Unfortunately, this is syntactically legal, so the compiler
will not warn you.  The effect of this statement is to leave
the value of {\tt index} unchanged.  This is often a difficult
bug to track down.

Remember, you can write {\tt index = index +1;}, or you
can write {\tt index++;}, but you shouldn't mix them.

\section{String concatenation}

Interestingly, the {\tt +} operator can be used on strings;
it performs string {\bf concatenation}.  To concatenate means to
join the two operands end to end.  For example:

\begin{verbatim}
  string fruit = "banana";
  string bakedGood = " nut bread";
  string dessert = fruit + bakedGood;
  cout << dessert << endl;
\end{verbatim}
%
The output of this program is {\tt banana nut bread}.

Unfortunately, the {\tt +} operator does not work on native
C strings, so you cannot write something like

\begin{verbatim}
  string dessert = "banana" + " nut bread";
\end{verbatim}
%
because both operands are C strings.  As long as one of the
operands is an {\tt string}, though, C++ will automatically
convert the other.

It is also possible to concatenate a character onto the
beginning or end of an {\tt string}.  In the following example, we
will use concatenation and character arithmetic to output
an abecedarian series.

``Abecedarian'' refers to a series or list in which the elements
appear in alphabetical order.  For example, in Robert McCloskey's book
{\em Make Way for Ducklings}, the names of the ducklings are Jack,
Kack, Lack, Mack, Nack, Ouack, Pack and Quack.  Here is a loop that
outputs these names in order:

\begin{verbatim}
  string suffix = "ack";

  char letter = 'J';
  while (letter <= 'Q') {
    cout << letter + suffix << endl;
    letter++;
  }
\end{verbatim}
%
The output of this program is:

\begin{verbatim}
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
\end{verbatim}
%
Of course, that's not quite right because I've misspelled ``Ouack''
and ``Quack.''  As an exercise, modify the program to correct
this error.

Again, be careful to use string concatenation only with {\tt string}s
and not with native C strings.  Unfortunately, an expression like
{\tt letter + "ack"} is syntactically legal in C++, although it
produces a very strange result, at least in my development environment.

\section{{\tt string}s are mutable}
\index{class!string}
\index{immutable}
\index{string}

You can change the letters in an {\tt string} one at a time
using the {\tt []} operator on the left side of an assignment.
For example,

\begin{verbatim}
  string greeting = "Hello, world!";
  greeting[0] = 'J';
  cout << greeting << endl;
\end{verbatim}
%
produces the output {\tt Jello, world!}.


\section{{\tt string}s are comparable}
\label{incomparable}
\index{class!string}
\index{comparison!string}
\index{string}

All the comparison operators that work on {\tt int}s and
{\tt double}s also work on {\tt strings}.  For example,
if you want to know if two strings are equal:

\begin{verbatim}
  if (word == "banana") {
    cout << "Yes, we have no bananas!" << endl;
  }
\end{verbatim}
%
The other comparison operations are useful for putting words
in alphabetical order.

\begin{verbatim}
  if (word < "banana") {
    cout << "Your word, " << word << ", comes before banana." << endl;
  } else if (word > "banana") {
    cout << "Your word, " << word << ", comes after banana." << endl;
  } else {
    cout << "Yes, we have no bananas!" << endl;
  }
\end{verbatim}
%
You should be aware, though, that the {\tt string} class does
not handle upper and lower case letters the same way that people
do.  All the upper case letters come before all the lower case
letters.  As a result,

\begin{verbatim}
Your word, Zebra, comes before banana.
\end{verbatim}
%
A common way to address this problem is to convert strings to a
standard format, like all lower-case, before performing the
comparison.  The next sections explains how.  I will not address the
more difficult problem, which is making the program realize that
zebras are not fruit.

\section{Character classification}

It is often useful to examine a character and test whether
it is upper or lower case, or whether it is a character or
a digit.  C++ provides a library of functions that perform
this kind of character classification.  In order to use these
functions, you have to include the header file {\tt ctype.h}.

\begin{verbatim}
  char letter = 'a';
  if (isalpha(letter)) {
    cout << "The character " << letter << " is a letter." << endl;
  }
\end{verbatim}
%
You might expect the return value from {\tt isalpha} to
be a {\tt bool}, but for reasons I don't even want to think
about, it is actually an integer that is
0 if the argument is not a letter, and some non-zero value
if it is.

This oddity is not as inconvenient as it seems, because it is
legal to use this kind of integer in a conditional, as shown
in the example.  The value 0 is treated as {\tt false}, and
all non-zero values are treated as {\tt true}.

Technically, this sort of thing should not be allowed---integers are
not the same thing as boolean values.  Nevertheless, the C++ habit of
converting automatically between types can be useful.

Other character classification functions include {\tt isdigit}, which
identifies the digits 0 through 9, and {\tt isspace}, which identifies
all kinds of ``white'' space, including spaces, tabs, newlines, and a
few others.  There are also {\tt isupper} and {\tt islower}, which
distinguish upper and lower case letters.

Finally, there are two functions that convert letters from one
case to the other, called {\tt toupper} and {\tt tolower}.  Both take
a single character as a parameter and return a (possibly
converted) character.

\begin{verbatim}
  char letter = 'a';
  letter = toupper (letter);
  cout << letter << endl;
\end{verbatim}
%
The output of this code is {\tt A}.

As an exercise, use the character classification and conversion
library to write functions named {\tt stringToUpper} and
{\tt stringToLower} that take a single {\tt string} as
a parameter, and that modify the string by converting all the
letters to upper or lower case.  The return type should be
{\tt void}.

\section{Other {\tt string} functions}

This chapter does not cover all the {\tt string} functions.
Two additional ones, {\tt c\_str} and {\tt substr}, are covered
in Section~\ref{finput} and Section~\ref{parsing}.

\section{Glossary}

\begin{description}

\item[object:] A collection of related data that comes with a set of
functions that operate on it.  The objects we have used so far are the
{\tt cout} object provided by the system, and {\tt string}s.

\item[index:]  A variable or value used to select one of the
members of an ordered set, like a character from a string.

\item[traverse:]  To iterate through all the elements of a set
performing a similar operation on each.

\item[counter:]  A variable used to count something, usually
initialized to zero and then incremented.

\item[increment:]  Increase the value of a variable by one.
The increment operator in C++ is {\tt ++}.  In fact, that's
why C++ is called C++, because it is meant to be one better
than C.

\item[decrement:]  Decrease the value of a variable by one.
The decrement operator in C++ is {\tt --}.

\item[concatenate:] To join two operands end-to-end.

\index{object}
\index{index}
\index{traverse}
\index{counter}
\index{increment}
\index{decrement}
\index{concatenate}

\end{description}

% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{Structures}
\label{structs}
\index{struct}

\section{Compound values}

Most of the data types we have been working with represent a single
value---an integer, a floating-point number, a boolean value.  {\tt
string}s are different in the sense that they are made up of smaller
pieces, the characters.  Thus, {\tt string}s are an example of a
{\bf compound} type.

Depending on what we are doing, we may want to treat a compound type
as a single thing (or object), or we may want to access its parts (or
instance variables).  This ambiguity is useful.

It is also useful to be able to create your own compound values.  C++
provides two mechanisms for doing that: {\bf structures} and {\bf
classes}.  We will start out with structures and get to classes in
Chapter~\ref{class} (there is not much difference between them).

\section{{\tt Point} objects}
\index{Point}
\index{struct!Point}

As a simple example of a compound structure, consider the concept of a
mathematical point.  At one level, a point is two numbers
(coordinates) that we treat collectively as a single object.  In
mathematical notation, points are often written in parentheses, with a
comma separating the coordinates.  For example, $(0, 0)$ indicates the
origin, and $(x, y)$ indicates the point $x$ units to the right and
$y$ units up from the origin.

A natural way to represent a point in C++ is with two {\tt double}s.
The question, then, is how to group these two values into
a compound object, or structure.  The answer is a {\tt struct}
definition:

\begin{verbatim}
struct Point {
  double x, y;
};  
\end{verbatim}
%
{\tt struct} definitions appear outside of any function definition,
usually at the beginning of the program (after the {\tt include}
statements).

This definition indicates that there are two elements in this
structure, named {\tt x} and {\tt y}.  These elements are called
{\bf instance variables}, for reasons I will explain a little
later.

It is a common error to leave off the semi-colon at the end of a
structure definition.  It might seem odd to put a semi-colon after a
squiggly-brace, but you'll get used to it.

Once you have defined the new structure, you can create variables
with that type:

\begin{verbatim}
  Point blank;
  blank.x = 3.0;
  blank.y = 4.0;   
\end{verbatim}
%
The first line is a conventional variable declaration: {\tt blank} has
type {\tt Point}.  The next two lines initialize the instance variables of the
structure.  The ``dot notation'' used here is similar to the syntax
for invoking a function on an object, as in {\tt fruit.length()}.
Of course, one difference is that function names are always followed
by an argument list, even if it is empty.

\index{declaration}
\index{statement!declaration}
\index{reference}
\index{state diagram}
\index{state}

The result of these assignments is shown in the following
state diagram:

\vspace{0.1in}
\centerline{\epsfig{figure=point.eps}}
\vspace{0.1in}

As usual, the name of the variable {\tt blank} appears outside the box
and its value appears inside the box.  In this case, that value is
a compound object with two named instance variables.

\section{Accessing instance variables}
\index{struct!instance variable}

You can read the values of an instance variable using the same syntax we
used to write them:

\begin{verbatim}
    int x = blank.x;
\end{verbatim}
%
The expression {\tt blank.x} means ``go to the object named {\tt
blank} and get the value of {\tt x}.''  In this case we assign that
value to a local variable named {\tt x}.  Notice that there is no
conflict between the local variable named {\tt x} and the instance
variable named {\tt x}.  The purpose of dot notation is to identify
{\em which} variable you are referring to unambiguously.

You can use dot notation as part of any C++ expression, so the
following are legal.

\begin{verbatim}
  cout << blank.x << ", " << blank.y << endl;
  double distance = blank.x * blank.x + blank.y * blank.y;
\end{verbatim}
%
The first line outputs {\tt 3, 4}; the second line calculates
the value 25.

\section{Operations on structures}
\index{struct!operations}

Most of the operators we have been using on other types, like
mathematical operators ( {\tt +}, {\tt \%}, etc.) and comparison
operators ({\tt ==}, {\tt >}, etc.), do not work on structures.
Actually, it is possible to define the meaning of these operators
for the new type, but we won't do that in this book.

On the other hand, the assignment operator {\em does} work for
structures.  It can be used in two ways: to initialize the instance
variables of a structure or to copy the instance variables from one
structure to another.  An initialization looks like this:

\begin{verbatim}
  Point blank = { 3.0, 4.0 };
\end{verbatim}
%
The values in squiggly braces get assigned to the instance variables of
the structure one by one, in order.  So in this case, {\tt x}
gets the first value and {\tt y} gets the second.

Unfortunately, this syntax can be used only in an initialization,
not in an assignment statement.  So the following is illegal.

\begin{verbatim}
  Point blank;
  blank = { 3.0, 4.0 };       // WRONG !!
\end{verbatim}
%
You might wonder why this perfectly reasonable statement should
be illegal; I'm not sure, but I think the problem is that the compiler
doesn't know what type the right hand side should be.  If you
add a typecast:

\begin{verbatim}
  Point blank;
  blank = (Point){ 3.0, 4.0 };
\end{verbatim}
%
That works.

It is legal to assign one structure to
another.  For example:

\begin{verbatim}
  Point p1 = { 3.0, 4.0 };
  Point p2 = p1;
  cout << p2.x << ", " <<  p2.y << endl;
\end{verbatim}
%
The output of this program is {\tt 3, 4}.

\section{Structures as parameters}
\index{parameter}
\index{struct!as parameter}

You can pass structures as parameters in the usual way.  For
example,

\begin{verbatim}
void printPoint (Point p) {
  cout << "(" << p.x << ", " << p.y << ")" << endl;
}
\end{verbatim}
%
{\tt printPoint} takes a point as an argument and outputs it in
the standard format.  If you call {\tt printPoint (blank)},
it will output {\tt (3, 4)}.

As a second example, we can rewrite the {\tt distance} function from
Section~\ref{distance} so that it takes two {\tt Point}s as parameters
instead of four {\tt double}s.

\begin{verbatim}
double distance (Point p1, Point p2) {
  double dx = p2.x - p1.x;
  double dy = p2.y - p1.y;
  return sqrt (dx*dx + dy*dy);
}
\end{verbatim}

\section{Call by value}
\index{parameter passing}
\index{call by value}

When you pass a structure as an argument, remember that the
argument and the parameter are not the same variable.  Instead,
there are two variables (one in the caller and one in the
callee) that have the same value, at least initially.  For
example, when we call {\tt printPoint}, the stack diagram
looks like this:

\vspace{0.1in}
\centerline{\epsfig{figure=point2.eps}}
\vspace{0.1in}
%
If {\tt printPoint} happened to change one of the instance variables
of {\tt p}, it would have no effect on {\tt blank}.  Of course, there
is no reason for {\tt printPoint} to modify its parameter, so this
isolation between the two functions is appropriate.

This kind of parameter-passing is called ``pass by value''
because it is the value of the structure (or other type) that
gets passed to the function.

\section{Call by reference}
\index{parameter passing}
\index{call by reference}
\index{reference}

An alternative parameter-passing mechanism that is available
in C++ is called ``pass by reference.''  This mechanism makes
it possible to pass a structure to a procedure and modify it.

For example, you can reflect a point around the 45-degree line by
swapping the two coordinates.  The most obvious (but incorrect) way to
write a {\tt reflect} function is something like this:

\begin{verbatim}
void reflect (Point p)      // WRONG !!
{
  double temp = p.x;
  p.x = p.y;
  p.y = temp;
}
\end{verbatim}
%
But this won't work, because the changes we make in {\tt reflect}
will have no effect on the caller.

Instead, we have to specify that we want to pass the parameter by
reference.  We do that by adding an ampersand ({\tt \&}) to the
parameter declaration:

\begin{verbatim}
void reflect (Point& p)
{
  double temp = p.x;
  p.x = p.y;
  p.y = temp;
}
\end{verbatim}
%
Now we can call the function in the usual way:

\begin{verbatim}
  printPoint (blank);
  reflect (blank);
  printPoint (blank);
\end{verbatim}
%
The output of this program is as expected:

\begin{verbatim}
(3, 4)
(4, 3)
\end{verbatim}
%
Here's how we would draw a stack diagram for this program:

\vspace{0.1in}
\centerline{\epsfig{figure=point3.eps}}
\vspace{0.1in}
%
The parameter {\tt p} is a reference to the structure named {\tt
blank}.  The usual representation for a reference is a dot with an
arrow that points to whatever the reference refers to.

The important thing to see in this diagram is that any changes that
{\tt reflect} makes in {\tt p} will also affect {\tt blank}.

Passing structures by reference is more versatile than passing by
value, because the callee can modify the structure.  It is also
faster, because the system does not have to copy the whole
structure.  On the other hand, it is less safe, since it is harder to
keep track of what gets modified where.  Nevertheless, in C++
programs, almost all structures are passed by reference almost all the
time.  In this book I will follow that convention.


\section{Rectangles}
\index{Rectangle}
\index{struct!Rectangle}

Now let's say that we want to create a structure to represent
a rectangle.  The question is, what information do I have to
provide in order to specify a rectangle?  To keep things simple
let's assume that the rectangle will be oriented vertically or
horizontally, never at an angle.

There are a few possibilities: I could specify the center of
the rectangle (two coordinates) and its size (width and height),
or I could specify one of the corners and the size, or I
could specify two opposing corners.

The most common choice in existing programs is to specify the
upper left corner of the rectangle and the size.  To do that
in C++, we will define a structure that contains a {\tt Point}
and two doubles.

\begin{verbatim}
struct Rectangle {
  Point corner;
  double width, height;
};  
\end{verbatim}
%
Notice that one structure can contain another.  In fact, this
sort of thing is quite common.  Of course, this means that in
order to create a {\tt Rectangle}, we have to create a {\tt Point}
first:

\begin{verbatim}
  Point corner = { 0.0, 0.0 };
  Rectangle box = { corner, 100.0, 200.0 };
\end{verbatim}
%
This code creates a new {\tt Rectangle} structure and initializes the
instance variables.  The figure shows the effect of this assignment.

\vspace{0.1in}
\centerline{\epsfig{figure=rectangle.eps}}
\vspace{0.1in}
%
We can access the {\tt width} and {\tt height} in the usual way:

\begin{verbatim}
  box.width += 50.0;
  cout << box.height << endl;
\end{verbatim}
%
In order to access the instance variables of {\tt corner}, we can use a
temporary variable:

\begin{verbatim}
  Point temp = box.corner;
  double x = temp.x;
\end{verbatim}
%
Alternatively, we can compose the two statements:

\index{composition}

\begin{verbatim}
  double x = box.corner.x;
\end{verbatim}
%
It makes the most sense to read this statement from right to
left: ``Extract {\tt x} from the {\tt corner} of the {\tt box},
and assign it to the local variable {\tt x}.''

While we are on the subject of composition, I should point
out that you can, in fact, create the {\tt Point} and the
{\tt Rectangle} at the same time:

\begin{verbatim}
  Rectangle box = { { 0.0, 0.0 }, 100.0, 200.0 };
\end{verbatim}
%
The innermost squiggly braces are the coordinates of the
corner point; together they make up the first of the three
values that go into the new {\tt Rectangle}.  This statement
is an example of {\bf nested structure}.

\index{nested structure}


\section{Structures as return types}
\index{struct!as return type}
\index{return}
\index{statement!return}

You can write functions that return structures.  For example,
{\tt findCenter} takes a {\tt Rectangle} as an argument and
returns a {\tt Point} that contains the coordinates of the
center of the {\tt Rectangle}:

\begin{verbatim}
Point findCenter (Rectangle& box)
{
  double x = box.corner.x + box.width/2;
  double y = box.corner.y + box.height/2;
  Point result = {x, y};
  return result;
}
\end{verbatim}
%
To call this function, we have to pass a box as an argument
(notice that it is being passed by reference), and assign the
return value to a {\tt Point} variable:

\begin{verbatim}
  Rectangle box = { {0.0, 0.0}, 100, 200 };
  Point center = findCenter (box);
  printPoint (center);
\end{verbatim}
%
The output of this program is {\tt (50, 100)}.

\section {Passing other types by reference}
\index{parameter passing}
\index{call by reference}
\index{reference}

It's not just structures that can be passed by reference.
All the other types we've seen can, too.  For example, to swap
two integers, we could write something like:

\begin{verbatim}
void swap (int& x, int& y)
{
  int temp = x;
  x = y;
  y = temp;
}
\end{verbatim}
%
We would call this function in the usual way:

\begin{verbatim}
  int i = 7;
  int j = 9;
  swap (i, j);
  cout << i << j << endl;
\end{verbatim}
%
The output of this program is {\tt 97}.  Draw a stack
diagram for this program to convince yourself this is true.
If the parameters {\tt x} and {\tt y} were declared as
regular parameters (without the {\tt \&}s), {\tt swap} would
not work.  It would modify {\tt x} and {\tt y} and have no
effect on {\tt i} and {\tt j}.

When people start passing things like integers by reference,
they often try to use an expression
as a reference argument.  For example:

\begin{verbatim}
  int i = 7;
  int j = 9;
  swap (i, j+1);         // WRONG!!
\end{verbatim}
%
This is not legal because the expression {\tt j+1} is not
a variable---it does not occupy a location that the reference
can refer to.  It is a little tricky to figure out exactly
what kinds of expressions can be passed by reference.  For now
a good rule of thumb is that reference arguments have to be
variables.

\section{Getting user input}
\label{input}
\index{input!keyboard}

The programs we have written so far are pretty predictable;
they do the same thing every time they run.  Most of the time,
though, we want programs that take input from the user and
respond accordingly.

There are many ways to get input, including keyboard
input, mouse movements and button clicks, as well as more exotic
mechanisms like voice control and retinal scanning.  In this
text we will consider only keyboard input.

\index{stream}
\index{cin}
\index{cout}

In the header file {\tt iostream},
C++ defines an object named {\tt cin} that handles input in
much the same way that {\tt cout} handles output.  To get an
integer value from the user:

\begin{verbatim}
  int x;
  cin >> x;
\end{verbatim}
%
The {\tt >>} operator causes the program to stop executing and
wait for the user to type something.  If the user types a valid
integer, the program converts it into an integer value and
stores it in {\tt x}.

\index{operator!{\tt >>}}

If the user types something other than an integer,
C++ doesn't report an error, or anything sensible like that.
Instead, it puts some meaningless value in {\tt x} and continues.

Fortunately, there is a way to check and see if an input
statement succeeds.  We can invoke the {\tt good} function on
{\tt cin} to check what is called the {\bf stream state}.
{\tt good} returns a {\tt bool}: if true, then the last input
statement succeeded.  If not, we know that some previous operation
failed, and also that the next operation will fail.

Thus, getting input from the user might look like this:

\begin{verbatim}
#include <iostream>

using namespace std;

int main ()
{
  int x;

  // prompt the user for input
  cout << "Enter an integer: ";

  // get input
  cin >> x;

  // check and see if the input statement succeeded
  if (cin.good() == false) {
    cout << "That was not an integer." << endl;
    return -1;
  }

  // print the value we got from the user
  cout << x << endl;
  return 0;
}
\end{verbatim}
%
{\tt cin} can also be used to input a {\tt string}:

\begin{verbatim}
  string name;

  cout << "What is your name? ";
  cin >> name;
  cout << name << endl;
\end{verbatim}
%
Unfortunately, this statement only takes the first word of
input, and leaves the rest for the next input statement.
So, if you run this program and type your full name, it
will only output your first name.

Because of these problems (inability to handle errors and
funny behavior), I avoid using the {\tt >>} operator altogether,
unless I am reading data from a source that is known to be
error-free.

Instead, I use a function in the header {\tt string} called {\tt getline}.

\begin{verbatim}
  string name;

  cout << "What is your name? ";
  getline (cin, name);
  cout << name << endl;
\end{verbatim}
%
The first argument to {\tt getline} is {\tt cin}, which is
where the input is coming from.  The second argument is the
name of the {\tt string} where you want the result to be
stored.

{\tt getline} reads the entire line until the user hits
Return or Enter.  This is useful for inputting strings that
contain spaces.

In fact, {\tt getline} is generally useful for getting input
of any kind.  For example, if you wanted the user to type an
integer, you could input a string and then check to see if
it is a valid integer.  If so, you can convert it to an integer
value.  If not, you can print an error message and ask the user
to try again.

To convert a string to an integer you can use the {\tt atoi}
function defined in the header file {\tt cstdlib}.  We will
get to that in Section~\ref{parsing}.

\section{Glossary}

\begin{description}

\item[structure:]  A collection of data grouped together and
treated as a single object.

\item[instance variable:]  One of the named pieces of data that make up
a structure.

\item[reference:]  A value that indicates or refers to a variable
or structure.  In a state diagram, a reference appears as an arrow.

\item[pass by value:]  A method of parameter-passing in which the
value provided as an argument is copied into the corresponding
parameter, but the parameter and the argument occupy distinct
locations.

\item[pass by reference:]  A method of parameter-passing in which
the parameter is a reference to the argument variable.  Changes
to the parameter also affect the argument variable.

\index{structure}
\index{instance variable}
\index{reference}
\index{pass by value}
\index{pass by reference}

\end{description}

% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{More structures}
\label{time}
\index{struct}

\section{Time}
\index{struct!Time}
\index{Time}

As a second example of a user-defined structure, we will define a type
called {\tt Time}, which is used to record the time of day.  The
various pieces of information that form a time are the hour, minute
and second, so these will be the instance variables of the structure.

The first step is to decide what type each instance variable should
be.  It seems clear that {\tt hour} and {\tt minute} should be
integers.  Just to keep things interesting, let's make {\tt second} a
{\tt double}, so we can record fractions of a second.

Here's what the structure definition looks like:

\begin{verbatim}
struct Time {
  int hour, minute;
  double second;
};
\end{verbatim}
%
We can create a {\tt Time} object in the usual way:

\begin{verbatim}
  Time time = { 11, 59, 3.14159 };
\end{verbatim}
%
The state diagram for this object looks like this:

\vspace{0.1in}
\centerline{\epsfig{figure=time.eps}}
\vspace{0.1in}

The word ``instance'' is sometimes used when we talk about objects,
because every object is an instance (or example) of some type.  The
reason that instance variables are so-named is that every instance of
a type has a copy of the instance variables for that type.

\section{{\tt printTime}}
\label{printobject}
\index{output}
\index{statement!output}
\index{object!output}

When we define a new type it is a good idea to write
function that displays the instance variables in a human-readable
form.  For example:

\begin{verbatim}
void printTime (Time& t) {
  cout << t.hour << ":" << t.minute << ":" << t.second << endl;
}
\end{verbatim}
%
The output of this function, if we pass {\tt time}
an argument, is {\tt 11:59:3.14159}.

\begin{verbatim}
#include <iostream>

using namespace std;

struct Time {
  int hour, minute;
  double second;
};


void printTime (Time& t) {
  cout << t.hour << ":" << t.minute << ":" << t.second << endl;
  cout << "Time is " << t.hour << " hour " << t.minute << " minutes " << t.second << "  seconds  "<<endl;
}


int main ()
{
 Time time = { 11, 59, 3.14159 };
 printTime(time);
 
 return 0;
}
\end{verbatim}
%

\section{Functions for objects}
\label{objectops}
\index{object}
\index{function!for objects}

In the next few
sections, I will demonstrate several possible interfaces for
functions that operate on objects.  For some operations, you will have a
choice of several possible interfaces, so you should consider the pros
and cons of each of these:

\begin{description}

\item[pure function:]  Takes objects and/or basic types as
arguments but does not modify the objects.  The return value is
either a basic type or a new object created inside the function.

\item[modifier:]  Takes objects as parameters and modifies some
or all of them.  Often returns void. \index{void}

\item[fill-in function:]  One of the parameters is an ``empty''
object that gets filled in by the function.  Technically, this is
a type of modifier.

\end{description}

\section{Pure functions}
\index{pure function}
\index{function}
\index{function!pure function}

A function is considered a pure function if the result depends only on
the arguments, and it has no side effects like modifying an argument
or outputting something.  The only result of calling a pure function is
the return value.

One example is {\tt after}, which compares two {\tt Time}s and
returns a {\tt bool} that indicates whether the first operand
comes after the second:

\begin{verbatim}
bool after (Time& time1, Time& time2) {
  if (time1.hour > time2.hour) return true;
  if (time1.hour < time2.hour) return false;

  if (time1.minute > time2.minute) return true;
  if (time1.minute < time2.minute) return false;

  if (time1.second > time2.second) return true;
  return false;
}
\end{verbatim}
%
What is the result of this function if the two times are equal?  Does
that seem like the appropriate result for this function?  If you were
writing the documentation for this function, would you mention that case
specifically?

A second example is {\tt addTime}, which calculates the sum of two
times.  For example, if it is {\tt 9:14:30}, and your breadmaker takes
3 hours and 35 minutes, you could use {\tt addTime} to figure out when
the bread will be done.

Here is a rough draft of this function that is not quite right:

\begin{verbatim}
Time addTime (Time& t1, Time& t2) {
  Time sum;
  sum.hour = t1.hour + t2.hour;
  sum.minute = t1.minute + t2.minute;
  sum.second = t1.second + t2.second;
  return sum;
}
\end{verbatim}
%
Here is an example of how to use this function.  If {\tt currentTime}
contains the current time and {\tt breadTime} contains the amount
of time it takes for your breadmaker to make bread, then you
could use {\tt addTime} to figure out when the bread will be
done.

\begin{verbatim}
  Time currentTime = { 9, 14, 30.0 };
  Time breadTime = { 3, 35, 0.0 };
  Time doneTime = addTime (currentTime, breadTime);
  printTime (doneTime);
\end{verbatim}
%
The output of this program is {\tt 12:49:30}, which is
correct.  On the other hand, there are cases where the result
is not correct.  Can you think of one?

The problem is that this function does not deal with cases
where the number of seconds or minutes adds up to more than
60.  When that happens we have to ``carry'' the extra seconds
into the minutes column, or extra minutes into the hours
column.

Here's a second, corrected version of this function.

\begin{verbatim}
Time addTime (Time& t1, Time& t2) {
  Time sum;
  sum.hour = t1.hour + t2.hour;
  sum.minute = t1.minute + t2.minute;
  sum.second = t1.second + t2.second;

  if (sum.second >= 60.0) {
    sum.second -= 60.0;
    sum.minute += 1;
  }
  if (sum.minute >= 60) {
    sum.minute -= 60;
    sum.hour += 1;
  }
  return sum;
}
\end{verbatim}
%
Although it's correct, it's starting to get big.  Later,
I will suggest an alternate approach to this problem that
will be much shorter.

\index{increment}
\index{decrement}
\index{operator!increment}
\index{operator!decrement}

This code demonstrates two operators we have not seen before, {\tt +=}
and {\tt -=}.  These operators provide a concise way to increment and
decrement variables.  For example, the statement {\tt sum.second -=
60.0;} is equivalent to {\tt sum.second = sum.second - 60;}

\section{{\tt const} parameters}

You might have noticed that the parameters for {\tt after}
and {\tt addTime} are being passed by reference.  Since
these are pure functions, they do not modify the parameters
they receive, so I could just as well have passed them by
value.

The advantage of passing by value is that the calling function
and the callee are appropriately encapsulated---it is not possible
for a change in one to affect the other, except by affecting
the return value.

On the other hand, passing by reference usually is more efficient,
because it avoids copying the argument.  Furthermore, there is a nice
feature in C++, called {\tt const}, that can make reference parameters
just as safe as value parameters.

If you are writing a function and you do not intend to modify
a parameter, you can declare that it is a {\bf constant
reference parameter}.  The syntax looks like this:

\begin{verbatim}
void printTime (const Time& time) ...
Time addTime (const Time& t1, const Time& t2) ...
\end{verbatim}
%
I've included only the first line of the functions.  If you tell
the compiler that you don't intend to change a
parameter, it can help remind you.  If you try to change one,
you should get a compiler error, or at least a warning.

\index{run-time error}
\index{error!run-time}

\section{Modifiers}
\index{modifier}
\index{function!modifier}

Of course, sometimes you {\em want} to modify one of the
arguments.  Functions that do are called modifiers.

As an example of a modifier, consider {\tt increment},
which adds a given number of seconds to a {\tt Time} object.
Again, a rough draft of this function looks like:

\begin{verbatim}
void increment (Time& time, double secs) {
  time.second += secs;

  if (time.second >= 60.0) {
    time.second -= 60.0;
    time.minute += 1;
  }
  if (time.minute >= 60) {
    time.minute -= 60;
    time.hour += 1;
  }
}
\end{verbatim}
%
The first line performs the basic operation; the remainder
deals with the special cases we saw before.

Is this function correct?  What happens if the argument {\tt secs}
is much greater than 60?  In that case, it is not enough to
subtract 60 once; we have to keep doing it until {\tt second}
is below 60.  We can do that by replacing the {\tt if}
statements with {\tt while} statements:

\begin{verbatim}
void increment (Time& time, double secs) {
  time.second += secs;

  while (time.second >= 60.0) {
    time.second -= 60.0;
    time.minute += 1;
  }
  while (time.minute >= 60) {
    time.minute -= 60;
    time.hour += 1;
  }
}
\end{verbatim}
%
This solution is correct, but not very efficient.
Can you think of a solution that does not require iteration?

\section{Fill-in functions}
\index{fill-in function}
\index{function!fill-in}

Occasionally you will see functions like {\tt addTime} written
with a different interface (different arguments and return values).
Instead of creating a new object every time {\tt addTime} is
called, we could require the caller to provide an ``empty''
object where {\tt addTime} can store the result.  Compare
the following with the previous version:

\begin{verbatim}
void addTimeFill (const Time& t1, const Time& t2, Time& sum) {
  sum.hour = t1.hour + t2.hour;
  sum.minute = t1.minute + t2.minute;
  sum.second = t1.second + t2.second;

  if (sum.second >= 60.0) {
    sum.second -= 60.0;
    sum.minute += 1;
  }
  if (sum.minute >= 60) {
    sum.minute -= 60;
    sum.hour += 1;
  }
}
\end{verbatim}
%
One advantage of this approach is that the caller has the option of
reusing the same object repeatedly to perform a series of additions.
This can be slightly more efficient, although it can be confusing
enough to cause subtle errors.  For the vast majority of programming,
it is worth a spending a little run time to avoid a lot of debugging
time.

Notice that the first two parameters can be declared {\tt const},
but the third cannot.

\section{Which is best?}
\index{programming style}

Anything that can be done with modifiers and fill-in functions can also
be done with pure functions.  In fact, there are programming
languages, called {\bf functional} programming languages, that only
allow pure functions.  Some programmers believe that programs that use
pure functions are faster to develop and less error-prone than
programs that use modifiers.  Nevertheless, there are times when
modifiers are convenient, and cases where functional programs
are less efficient.

In general, I recommend that you write pure functions whenever
it is reasonable to do so, and resort to modifiers only if there
is a compelling advantage.  This approach might be called a
functional programming style.

\section{Incremental development versus planning}
\index{incremental development}
\index{prototyping}
\index{program development!incremental}
\index{program development!planning}

In this chapter I have demonstrated an approach to program
development I refer to as {\bf rapid prototyping with iterative
improvement}.  In each case, I wrote a rough draft (or prototype)
that performed the basic calculation, and then tested it on
a few cases, correcting flaws as I found them.

Although this approach can be effective, it can lead to code
that is unnecessarily complicated---since it deals with many
special cases---and unreliable---since it is hard to know if
you have found all the errors.

An alternative is high-level planning, in which a little insight
into the problem can make the programming much easier.  In
this case the insight is that a {\tt Time} is really a three-digit
number in base 60!  The {\tt second} is the ``ones column,''
the {\tt minute} is the ``60's column'', and the {\tt hour}
is the ``3600's column.''

When we wrote {\tt addTime} and {\tt increment}, we were effectively
doing addition in base 60, which is why we had to ``carry'' from one
column to the next.

\index{arithmetic!base 60}
\index{arithmetic!floating-point}

Thus an alternate approach to the whole problem is to convert
{\tt Time}s into {\tt double}s and take advantage of the fact that
the computer already knows how to do arithmetic with {\tt double}s.
Here is a function that converts a {\tt Time} into a {\tt double}:

\begin{verbatim}
double convertToSeconds (const Time& t) {
  int minutes = t.hour * 60 + t.minute;
  double seconds = minutes * 60 + t.second;
  return seconds;
}
\end{verbatim}
%
Now all we need is a way to convert from a {\tt double}
to a {\tt Time} object:

\begin{verbatim}
Time makeTime (double secs) {
  Time time;
  time.hour = int (secs / 3600.0);
  secs -= time.hour * 3600.0;
  time.minute = int (secs / 60.0);
  secs -= time.minute * 60;
  time.second = secs;
  return time;
}
\end{verbatim}
%
You might have to think a bit to convince yourself that the technique
I am using to convert from one base to another is correct.  Assuming
you are convinced, we can use these functions to rewrite {\tt addTime}:

\begin{verbatim}
Time addTime (const Time& t1, const Time& t2) {
  double seconds = convertToSeconds (t1) + convertToSeconds (t2);
  return makeTime (seconds);
}
\end{verbatim}
%
This is much shorter than the original version, and it is much easier
to demonstrate that it is correct (assuming, as usual, that the
functions it calls are correct).  As an exercise, rewrite {\tt
increment} the same way.


\section{Generalization}
\index{generalization}

In some ways converting from base 60 to base 10 and back is
harder than just dealing with times.  Base conversion is more
abstract; our intuition for dealing with times is better.

But if we have the insight to treat times as base 60 numbers,
and make the investment of writing the conversion functions
({\tt convertToSeconds} and {\tt makeTime}), we get
a program that is shorter, easier to read and debug, and more
reliable.

It is also easier to add more features later.  For example, imagine
subtracting two {\tt Time}s to find the duration between them.  The
naive approach would be to implement subtraction with
borrowing.  Using the conversion functions would be easier and more
likely to be correct.

Ironically, sometimes making a problem harder (more general)
makes is easier (fewer special cases, fewer opportunities for error).

\section{Algorithms}
\label{algorithm}
\index{algorithm}

When you write a general solution for a class of problems, as opposed
to a specific solution to a single problem, you have written an {\bf
algorithm}.  I mentioned this word in Chapter 1, but did not define it
carefully.  It is not easy to define, so I will try a couple of
approaches.

First, consider something that is not an algorithm.
When you learned to multiply single-digit numbers, you probably
memorized the multiplication table.  In effect, you memorized 100
specific solutions.  That kind of knowledge is not really algorithmic.

But if you were ``lazy,'' you probably cheated by learning a few
tricks.  For example, to find the product of $n$ and 9, you can write
$n-1$ as the first digit and $10-n$ as the second digit.  This trick
is a general solution for multiplying any single-digit number by 9.
That's an algorithm!

Similarly, the techniques you learned for addition with carrying,
subtraction with borrowing, and long division are all algorithms.  One
of the characteristics of algorithms is that they do not require any
intelligence to carry out.  They are mechanical processes in which
each step follows from the last according to a simple set of rules.

In my opinion, it is embarrassing that humans spend so much time in
school learning to execute algorithms that, quite literally, require
no intelligence.

On the other hand, the process of designing algorithms is interesting,
intellectually challenging, and a central part of what we call
programming.

Some of the things that people do naturally, without difficulty
or conscious thought, are the most difficult to express
algorithmically.  Understanding natural language is a good
example.  We all do it, but so far no one has been able to
explain {\em how} we do it, at least not in the form of an
algorithm.

Later in this book, you will have the opportunity to design
simple algorithms for a variety of problems.  If you take
the next class in the Computer Science sequence, Data Structures,
you will see some of the most interesting, clever, and
useful algorithms computer science has produced.

\section{Glossary}

\begin{description}

\item[instance:]  An example from a category.  My cat is an
instance of the category ``feline things.''  Every object is
an instance of some type.

\item[instance variable:]  One of the named data items that make
up an structure.  Each structure has its own copy of
the instance variables for its type.

\item[constant reference parameter:]  A parameter that is passed
by reference but that cannot be modified.

\item[pure function:]  A function whose result depends only on its
parameters, and that has so effects other than returning
a value.

\item[functional programming style:]  A style of program design
in which the majority of functions are pure.

\item[modifier:]  A function that changes one or more of the objects
it receives as parameters, and usually returns {\tt void}.

\item[fill-in function:]  A function that takes an ``empty''
object as a parameter and fills it its instance variables instead
of generating a return value.

\item[algorithm:]  A set of instructions for solving a class of
problems by a mechanical, unintelligent process.

\index{instance}
\index{instance variable}
\index{pure function}
\index{functional programming}
\index{modifier}
\index{algorithm}

\end{description}

% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{Member functions}

\section{Objects and functions}
\index{member function}
\index{function!member}

C++ is generally considered an object-oriented programming language,
which means that it provides features that support object-oriented
programming.

It's not easy to define object-oriented programming, but we have
already seen some features of it:

\begin{enumerate}

\item Programs are made up of a collection of structure definitions
and function definitions, where most of the functions operate on
specific kinds of structures (or objecs).

\item Each structure definition corresponds to some
object or concept in the real world, and the functions that operate
on that structure correspond to the ways real-world objects interact.

\end{enumerate}

For example, the {\tt Time} structure we defined in Chapter~\ref{time}
obviously corresponds to the way people record the time of day,
and the operations we defined correspond to the sorts of things
people do with recorded times.  Similarly, the {\tt Point} and
{\tt Rectangle} structures correspond to the mathematical concept
of a point and a rectangle.

So far, though, we have not taken advantage of the features C++
provides to support object-oriented programming.  Strictly speaking,
these features are not necessary.  For the most part they provide
an alternate syntax for doing things we have already done, but
in many cases the alternate syntax is more concise and more
accurately conveys the structure of the program.

For example, in the {\tt Time} program, there is
no obvious connection between the structure definition and the
function definitions that follow.  With some examination, it
is apparent that every function takes at least one {\tt Time}
structure as a parameter.

This observation is the motivation for {\bf member functions}.
Member function differ from the other functions we have written
in two ways:

\begin{enumerate}

\item When we call the function, we {\bf invoke} it on an
object, rather than just call it.  People sometimes describe
this process as ``performing an operation on an object,'' or
``sending a message to an object.''

\item The function is {\em declared} inside the {\tt struct}
definition, in order to make the relationship between the
structure and the function explicit.

\end{enumerate}

In the next few sections, we will take the functions from
Chapter~\ref{time} and transform them into member functions.
One thing you should realize is that this transformation is
purely mechanical; in other words, you can do it just by following
a sequence of steps.

\index{nonmember function}
\index{function!nonmember}

As I said, anything that can be done with a member function can
also be done with a nonmember function (sometimes called a
{\bf free-standing} function).   But sometimes there is an
advantage to one over the other.  If you are comfortable converting
from one form to another, you will be able to choose the best
form for whatever you are doing.

\section{{\tt print}}

In Chapter~\ref{time} we defined a structure named {\tt Time}
and wrote a function named {\tt printTime}

\begin{verbatim}
struct Time {
  int hour, minute;
  double second;
};

void printTime (const Time& time) {
  cout << time.hour << ":" << time.minute << ":" << time.second << endl;
}
\end{verbatim}
%
To call this function, we had to pass a {\tt Time} object as
a parameter.

\begin{verbatim}
  Time currentTime = { 9, 14, 30.0 };
  printTime (currentTime);
\end{verbatim}
%
To make {\tt printTime} into a member function, the
first step is to change the name of the function from {\tt printTime}
to {\tt Time::print}.  The {\tt ::} operator separates the name
of the structure from the name of the function; together they
indicate that this is a function named {\tt print} that can be
invoked on a {\tt Time} structure.

The next step is to eliminate the parameter.  Instead of passing
an object as an argument, we are going to invoke the function
on an object.

As a result, inside the function, we no longer have a parameter named
{\tt time}.  Instead, we have a {\bf current object}, which is the
object the function is invoked on.  We can refer to the current object
using the C++ keyword {\tt this}.

\index{current object}
\index{object!current}
\index{pointer}
\index{this}

One thing that makes life a little difficult is that {\tt this}
is actually a {\bf pointer} to a structure, rather than a structure
itself.  A pointer is similar to a reference, but I don't want
to go into the details of using pointers yet.  The only pointer
operation we need for now is the {\tt *} operator, which converts
a structure pointer into a structure.  In the following
function, we use it to assign the value of {\tt this} to a local
variable named {\tt time}:

\begin{verbatim}
void Time::print () {
  Time time = *this;
  cout << time.hour << ":" << time.minute << ":" << time.second << endl;
}
\end{verbatim}
%
The first two lines of this function changed quite a bit as we
transformed it into a member function, but notice that the output
statement itself did not change at all.

In order to invoke the new version of {\tt print}, we have
to invoke it on a {\tt Time} object:

\begin{verbatim}
  Time currentTime = { 9, 14, 30.0 };
  currentTime.print ();
\end{verbatim}
%
The last step of the transformation process is that we have to
declare the new function inside the structure definition:

\begin{verbatim}
struct Time {
  int hour, minute;
  double second;

  void Time::print ();
};
\end{verbatim}
%
A {\bf function declaration} looks just like the first line of the
function definition, except that it has a semi-colon at the end.  The
declaration describes the {\bf interface} of the function; that is,
the number and types of the arguments, and the type of the return
value.

When you declare a function, you are making a promise to the compiler
that you will, at some point later on in the program, provide a
definition for the function.  This definition is sometimes called
the {\bf implementation} of the function, since it contains the
details of how the function works.  If you omit the definition, or
provide a definition that has an interface different from what
you promised, the compiler will complain.

\section {Implicit variable access}

Actually, the new version of {\tt Time::print} is more complicated
than it needs to be.  We don't really need to create a local
variable in order to refer to the instance variables of the current
object.

If the function refers to {\tt hour}, {\tt minute}, or {\tt second},
all by themselves with no dot notation, C++ knows that it must
be referring to the current object.  So we could have written:

\begin{verbatim}
void Time::print ()
{
  cout << hour << ":" << minute << ":" << second << endl;
}
\end{verbatim}
%
This kind of variable access is called ``implicit'' because the
name of the object does not appear explicitly.  Features like
this are one reason member functions are often more concise
than nonmember functions.

\section {Another example}

Let's convert {\tt increment} to a member function.  Again, we
are going to transform one of the parameters into the implicit
parameter called {\tt this}.  Then we can go through the function
and make all the variable accesses implicit.

\begin{verbatim}
void Time::increment (double secs) {
  second += secs;

  while (second >= 60.0) {
    second -= 60.0;
    minute += 1;
  }
  while (minute >= 60) {
    minute -= 60.0;
    hour += 1;
  }
}
\end{verbatim}
%
By the way, remember that this is not the most efficient implementation
of this function.  If you didn't do it back in Chapter~\ref{time}, you
should write a more efficient version now.

To declare the function, we can just copy the first line into the
structure definition:

\begin{verbatim}
struct Time {
  int hour, minute;
  double second;

  void Time::print ();
  void Time::increment (double secs);
};
\end{verbatim}
%
And again, to call it, we have to invoke it on a {\tt Time}
object:

\begin{verbatim}
  Time currentTime = { 9, 14, 30.0 };
  currentTime.increment (500.0);
  currentTime.print ();
\end{verbatim}
%
The output of this program is {\tt 9:22:50}.

\section{Yet another example}

The original version of {\tt convertToSeconds} looked like this:

\begin{verbatim}
double convertToSeconds (const Time& time) {
  int minutes = time.hour * 60 + time.minute;
  double seconds = minutes * 60 + time.second;
  return seconds;
}
\end{verbatim}
%
It is straightforward to convert this to a member function:

\begin{verbatim}
double Time::convertToSeconds () const {
  int minutes = hour * 60 + minute;
  double seconds = minutes * 60 + second;
  return seconds;
}
\end{verbatim}
%
The interesting thing here is that the implicit parameter should
be declared {\tt const}, since we don't modify it in this function.
But it is not obvious where we should put information about a
parameter that doesn't exist.  The answer, as you can see in the
example, is after the parameter list (which is empty in this case).

The {\tt print} function in the previous section should also
declare that the implicit parameter is {\tt const}.

\section {A more complicated example}

Although the process of transforming functions into member
functions is mechanical, there are some oddities.  For example,
{\tt after} operates on two {\tt Time} structures, not just
one, and we can't make both of them implicit.  Instead, we have
to invoke the function on one of them and pass the other as
an argument.

Inside the function, we can refer to one of the them implicitly,
but to access the instance variables of the other we continue
to use dot notation.

\begin{verbatim}
bool Time::after (const Time& time2) const {
  if (hour > time2.hour) return true;
  if (hour < time2.hour) return false;

  if (minute > time2.minute) return true;
  if (minute < time2.minute) return false;

  if (second > time2.second) return true;
  return false;
}
\end{verbatim}
%
To invoke this function:

\begin{verbatim}
  if (doneTime.after (currentTime)) {
    cout << "The bread will be done after it starts." << endl;
  }
\end{verbatim}
%
You can almost read the invocation like English: ``If the
done-time is after the current-time, then...''

\section{Constructors}

Another function we wrote in Chapter~\ref{time} was
{\tt makeTime}:

\begin{verbatim}
Time makeTime (double secs) {
  Time time;
  time.hour = int (secs / 3600.0);
  secs -= time.hour * 3600.0;
  time.minute = int (secs / 60.0);
  secs -= time.minute * 60.0;
  time.second = secs;
  return time;
}
\end{verbatim}
%
Of course, for every new type, we need to be able to create
new objects.  In fact, functions like {\tt makeTime} are so
common that there is a special function syntax for them.  These
functions are called {\bf constructors} and the syntax looks
like this:

\begin{verbatim}
Time::Time (double secs) {
  hour = int (secs / 3600.0);
  secs -= hour * 3600.0;
  minute = int (secs / 60.0);
  secs -= minute * 60.0;
  second = secs;
}
\end{verbatim}
%
First, notice that the constructor has the same name as the
class, and no return type.  The arguments haven't changed, though.

Second, notice that we don't have to create a new time object,
and we don't have to return anything.  Both of these steps are
handled automatically.  We can refer to the new object---the one
we are constructing---using the keyword {\tt this}, or implicitly
as shown here.  When we write values to {\tt hour}, {\tt minute}
and {\tt second}, the compiler knows we are referring to the instance
variables of the new object.

To invoke the constructor, you use syntax that is a cross
between a variable declaration and a function call:

\begin{verbatim}
  Time time (seconds);
\end{verbatim}
%
This statement declares that the variable {\tt time} has
type {\tt Time}, and it invokes the constructor we just wrote,
passing the value of {\tt seconds} as an argument.  The system
allocates space for the new object and the constructor initializes
its instance variables.  The result is assigned to the variable
{\tt time}.


\section {Initialize or construct?}

Earlier we declared and initialized some {\tt Time} structures
using squiggly-braces:

\begin{verbatim}
  Time currentTime = { 9, 14, 30.0 };
  Time breadTime = { 3, 35, 0.0 };
\end{verbatim}
%
Now, using constructors, we have a different way to declare
and initialize:

\begin{verbatim}
  Time time (seconds);
\end{verbatim}
%
These two functions represent different programming styles, and
different points in the history of C++.  Maybe
for that reason, the C++ compiler requires that you use one or
the other, and not both in the same program.

If you define a constructor for a structure, then you have to
use the constructor to initialize all new structures of that
type.  The alternate syntax using squiggly-braces is no longer
allowed.

Fortunately, it is legal to overload constructors in the same
way we overloaded functions.  In other words, there can be more
than one constructor with the same ``name,'' as long as they
take different parameters.  Then, when we initialize a new object
the compiler will try to find a constructor that takes the
appropriate parameters.

For example, it is common to have a constructor that takes
one parameter for each instance variable, and that assigns
the values of the parameters to the instance variables:

\begin{verbatim}
Time::Time (int h, int m, double s)
{
  hour = h;  minute = m;  second = s;
}
\end{verbatim}
%
To invoke this constructor, we use the same funny syntax
as before, except that the arguments have to be two integers
and a {\tt double}:

\begin{verbatim}
  Time currentTime (9, 14, 30.0);
\end{verbatim}

\section {One last example}

The final example we'll look at is {\tt addTime}:

\begin{verbatim}
Time addTime2 (const Time& t1, const Time& t2) {
  double seconds = convertToSeconds (t1) + convertToSeconds (t2);
  return makeTime (seconds);
}
\end{verbatim}
%
We have to make several changes to this function, including:

\begin{enumerate}

\item Change the name from {\tt addTime} to {\tt Time::add}.

\item Replace the first parameter with an implicit parameter,
which should be declared {\tt const}.

\item Replace the use of {\tt makeTime} with a constructor
invocation.

\end{enumerate}
%
Here's the result:

\begin{verbatim}
Time Time::add (const Time& t2) const {
  double seconds = convertToSeconds () + t2.convertToSeconds ();
  Time time (seconds);
  return time;
}
\end{verbatim}
%
The first time we invoke {\tt convertToSeconds},
there is no apparent object!  Inside a member function, the compiler
assumes that we want to invoke the function on the current object.
Thus, the first invocation acts on {\tt this}; the second
invocation acts on {\tt t2}.

The next line of the function invokes the constructor that
takes a single {\tt double} as a parameter; the last line returns
the resulting object.

\section {Header files}

It might seem like a nuisance to declare functions inside
the structure definition and then define the functions later.
Any time you change the interface to a function, you have
to change it in two places, even if it is a small change
like declaring one of the parameters {\tt const}.

There is a reason for the hassle, though, which is that it
is now possible to separate the structure definition and the
functions into two files: the {\bf header file},
which contains the structure definition, and the implementation
file, which contains the functions.

Header files usually have the same name as the implementation
file, but with the suffix {\tt .h} instead of {\tt .cpp}.  For
the example we have been looking at, the header file is called
{\tt Time.h}, and it contains the following:

\begin{verbatim}
struct Time {
  // instance variables
  int hour, minute;
  double second;

  // constructors
  Time (int hour, int min, double secs);
  Time (double secs);

  // modifiers
  void increment (double secs);

  // functions
  void print () const;
  bool after (const Time& time2) const;
  Time add (const Time& t2) const;
  double convertToSeconds () const;
};
\end{verbatim}
%
Notice that in the structure definition I don't really have
to include the prefix {\tt Time::} at the beginning of every
function name.  The compiler knows that we are declaring functions
that are members of the {\tt Time} structure.

{\tt Time.cpp} contains the definitions of the member functions
(I have elided the function bodies to save space):

\begin{verbatim}
#include <iostream>
using namespace std;
#include "Time.h"

Time::Time (int h, int m, double s)  ...

Time::Time (double secs) ...

void Time::increment (double secs) ...

void Time::print () const ...

bool Time::after (const Time& time2) const ...

Time Time::add (const Time& t2) const ...

double Time::convertToSeconds () const ...
\end{verbatim}
%
In this case the definitions in {\tt Time.cpp} appear in the
same order as the declarations in {\tt Time.h}, although it
is not necessary.

On the other hand, it is necessary to include the header
file using an {\tt include} statement.  That way, while the
compiler is reading the function definitions, it knows enough
about the structure to check the code and catch errors.

Finally, {\tt main.cpp} contains the function {\tt main} along
with any functions we want that are not members of the {\tt Time}
structure (in this case there are none):

\begin{verbatim}
#include <iostream>
using namespace std;
#include "Time.h"

int main ()
{
  Time currentTime (9, 14, 30.0);
  currentTime.increment (500.0);
  currentTime.print ();

  Time breadTime (3, 35, 0.0);
  Time doneTime = currentTime.add (breadTime);
  doneTime.print ();

  if (doneTime.after (currentTime)) {
    cout << "The bread will be done after it starts." << endl;
  }
  return 0;
}

\end{verbatim}
%
Again, {\tt main.cpp} has to include the header file.

It may not be obvious why it is useful to break such a small
program into three pieces.  In fact, most of the advantages come
when we are working with larger programs:

\begin{description}

\item[Reuse:]  Once you have written a structure like {\tt Time},
you might find it useful in more than one program.  By separating
the definition of {\tt Time} from {\tt main.cpp}, you make is easy
to include the {\tt Time} structure in another program.

\item[Managing interactions:]  As systems become large, the number
of interactions between components grows and quickly becomes
unmanageable.  It is often useful to minimize these interactions
by separating modules like {\tt Time.cpp} from the programs that
use them.

\item[Separate compilation:]  Separate files can be compiled
separately and then linked into a single program later.  The details
of how to do this depend on your programming environment.  As
the program gets large, separate compilation can save a lot of time,
since you usually need to compile only a few files at a time.

\end{description}

For small programs like the ones in this book, there is
no great advantage to splitting up programs.  But it is good
for you to know about this feature, especially since it explains
one of the statements that appeared in the first program we
wrote:

\begin{verbatim}
#include <iostream>
using namespace std;
\end{verbatim}
%
{\tt iostream} is the header file that contains declarations
for {\tt cin} and {\tt cout} and the functions that operate on
them.  When you compile your program, you need the information
in that header file.

The implementations of those functions are stored in a library,
sometimes called the ``Standard Library'' that gets linked to
your program automatically.  The nice thing is that you don't
have to recompile the library every time you compile a program.
For the most part the library doesn't change, so there is no
reason to recompile it.

\section{Glossary}

\begin{description}

\item[member function:]  A function that operates on an object
that is passed as an implicit parameter named {\tt this}.

\item[nonmember function:]  A function that is not a member
of any structure definition.  Also called a ``free-standing''
function.

\item[invoke:] To call a function ``on'' an object, in order to
pass the object as an implicit parameter.

\item[current object:]  The object on which a member function
is invoked.  Inside the member function, we can refer to the
current object implicitly, or by using the keyword {\tt this}.

\item[this:]  A keyword that refers to the current object.
{\tt this} is a pointer, which makes it difficult to use, since
we do not cover pointers in this book.

\item[interface:] A description of how a function is used, including
the number and types of the parameters and the type of the return
value.

\item[function declaration:] A statement that declares the interface
to a function without providing the body.  Declarations of
member functions appear inside structure definitions even if the
definitions appear outside.

\item[implementation:] The body of a function, or the details of how
a function works.

\item[constructor:] A special function that initializes the instance
variables of a newly-created object.

\index{member function}
\index{nonmember function}
\index{function!member}
\index{function!nonmember}
\index{interface}
\index{implementation}
\index{invoke}
\index{constructor}

\end{description}

% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{Vectors of Objects}

\section{Composition}
\index{composition}
\index{nested structure}

By now we have seen several examples of composition (the ability to
combine language features in a variety of arrangements).  One of the
first examples we saw was using a function invocation as part of an
expression.  Another example is the nested structure of statements:
you can put an {\tt if} statement within a {\tt while} loop, or within
another {\tt if} statement, etc.

Having seen this pattern, and having learned about vectors and objects,
you should not be surprised to learn that you can have vectors of
objects.  In fact, you can also have objects that contain vectors (as
instance variables); you can have vectors that contain vectors; you can
have objects that contain objects, and so on.

In the next two chapters we will look at some examples of these
combinations, using {\tt Card} objects as a case study.

\section{{\tt Card} objects}
\index{Card}
\index{class!Card}

If you are not familiar with common playing cards, now would be a good
time to get a deck, or else this chapter might not make much sense.
There are 52 cards in a deck, each of which belongs to one of four
suits and one of 13 ranks.  The suits are Spades, Hearts, Diamonds and
Clubs (in descending order in Bridge).  The ranks are Ace, 2, 3, 4, 5,
6, 7, 8, 9, 10, Jack, Queen and King.  Depending on what game you are
playing, the rank of the Ace may be higher than King or lower than 2.

\index{rank}
\index{suit}

If we want to define a new object to represent a playing card, it is
pretty obvious what the instance variables should be: {\tt rank} and
{\tt suit}.  It is not as obvious what type the instance variables
should be.  One possibility is {\tt apstring}s, containing things like
{\tt "Spade"} for suits and {\tt "Queen"} for ranks.  One problem with
this implementation is that it would not be easy to compare cards to
see which had higher rank or suit.

\index{encode}
\index{encrypt}
\index{map to}

An alternative is to use integers to {\bf encode} the ranks and
suits.  By ``encode,'' I do not mean what some people think, which
is to encrypt, or translate into a secret code.  What a computer
scientist means by ``encode'' is something like ``define a mapping
between a sequence of numbers and the things I want to represent.''
For example,

\vspace{0.1in}
\begin{tabular}{l c l}
Spades & $\mapsto$ & 3 \\
Hearts & $\mapsto$ & 2 \\
Diamonds & $\mapsto$ & 1 \\
Clubs & $\mapsto$ & 0
\end{tabular}
\vspace{0.1in}

The symbol $\mapsto$ is mathematical notation for ``maps to.''
The obvious feature of this mapping is that the suits map to
integers in order, so we can compare suits by comparing integers.
The mapping for ranks is fairly obvious; each of the numerical
ranks maps to the corresponding integer, and for face cards:

\vspace{0.1in}
\begin{tabular}{l c l}
Jack & $\mapsto$ & 11 \\
Queen & $\mapsto$ & 12 \\
King & $\mapsto$ & 13 \\
\end{tabular}
\vspace{0.1in}

The reason I am using mathematical notation for these mappings is
that they are not part of the C++ program.  They are part of the
program design, but they never appear explicitly in the code.
The class definition for the {\tt Card} type looks like this:

\begin{verbatim}
struct Card
{
  int suit, rank;

  Card ();
  Card (int s, int r);
};

Card::Card () { 
  suit = 0;  rank = 0;
}

Card::Card (int s, int r) { 
  suit = s;  rank = r;
}
\end{verbatim}
%
There are two constructors for {\tt Card}s.  You can tell that
they are constructors because they have no return type and their
name is the same as the name of the structure.  The first
constructor takes no arguments and initializes the instance
variables to a useless value (the zero of clubs).

The second constructor is more useful.  It takes two parameters,
the suit and rank of the card.

\index{constructor}

The following code creates an object named {\tt threeOfClubs}
that represents
the 3 of Clubs:

\begin{verbatim}
   Card threeOfClubs (0, 3);
\end{verbatim}
%
The first argument, {\tt 0} represents the suit Clubs, the
second, naturally, represents the rank 3.

\section{The {\tt printCard} function}
\index{printCard}
\index{print!Card}

When you create a new type, the first step is usually to declare the
instance variables and write constructors.  The second step is often
to write a function that prints the object in human-readable form.

\index{apstring!vector of}
\index{vector!of apstring}

In the case of {\tt Card} objects, ``human-readable'' means that we
have to map the internal representation of the rank and suit onto
words.  A natural way to do that is with a vector of {\tt apstring}s.
You can create a vector of {\tt apstring}s the same way you create an
vector of other types:

\begin{verbatim}
  apvector<apstring> suits (4);
\end{verbatim}
%
Of course, in order to use {\tt apvector}s and {\tt apstring}s, you
will have to include the header files for both\footnote{{\tt apvector}s
are a little different from {\tt apstring}s in this regard.
The file {\tt apvector.cpp} contains a template that allows the
compiler to create vectors of various kinds.  The first time you
use a vector of integers, the compiler generates code
to support that kind of vector.  If you use a vector of {\tt apstring}s,
the compiler generates different code to handle that kind of
vector.  As a result, it is usually sufficient to include the
header file {\tt apvector.h}; you do not have to compile
{\tt apvector.cpp} at all!  Unfortunately, if you do, you are
likely to get a long stream of error messages.  I hope this
footnote helps you avoid an unpleasant surprise, but the details
in your development environment may differ.}.

To initialize the elements of the vector, we can use a series of
assignment statements.

\begin{verbatim}
  suits[0] = "Clubs";
  suits[1] = "Diamonds";
  suits[2] = "Hearts";
  suits[3] = "Spades";
\end{verbatim}
%
A state diagram for this vector looks like this:

\index{state diagram}

\vspace{0.1in}
\centerline{\epsfig{figure=apstringvector.eps}}
\vspace{0.1in}

We can build a similar vector to decode the ranks.
Then we can select the appropriate elements
using the {\tt suit} and {\tt rank} as indices.  Finally, we can
write a function called {\tt print} that outputs the card on which
it is invoked:

\begin{verbatim}
void Card::print () const
{
  apvector<apstring> suits (4);
  suits[0] = "Clubs";
  suits[1] = "Diamonds";
  suits[2] = "Hearts";
  suits[3] = "Spades";

  apvector<apstring> ranks (14);
  ranks[1] = "Ace";
  ranks[2] = "2";
  ranks[3] = "3";
  ranks[4] = "4";
  ranks[5] = "5";
  ranks[6] = "6";
  ranks[7] = "7";
  ranks[8] = "8";
  ranks[9] = "9";
  ranks[10] = "10";
  ranks[11] = "Jack";
  ranks[12] = "Queen";
  ranks[13] = "King";

  cout << ranks[rank] << " of " << suits[suit] << endl;
}
\end{verbatim}
%
The expression {\tt suits[suit]} means ``use the instance variable
{\tt suit} from the current object as an index into the vector named
{\tt suits}, and select the appropriate string.''

Because {\tt print} is a {\tt Card} member function,
it can refer to the instance variables of the current object
implicitly (without having to use dot notation to specify the
object).  The output of this code

\begin{verbatim}
  Card card (1, 11);
  card.print ();
\end{verbatim}
%
is {\tt Jack of Diamonds}.

You might notice that we are not using the zeroeth element of the {\tt
ranks} vector.  That's because the only valid ranks are 1--13.  By
leaving an unused element at the beginning of the vector, we get an
encoding where 2 maps to ``2'', 3 maps to ``3'', etc.  From the point
of view of the user, it doesn't matter what the encoding is, since all
input and output uses human-readable formats.  On the other hand, it
is often helpful for the programmer if the mappings are easy
to remember.

\section{The {\tt equals} function}
\index{same}

In order for two cards to be equal, they have to have the same rank
and the same suit.  Unfortunately, the {\tt ==} operator does not work
for user-defined types like {\tt Card}, so we have to write a function
that compares two cards.  We'll call it {\tt equals}.  It is also
possible to write a new definition for the {\tt ==} operator, but we
will not cover that in this book.

It is clear that the return value from {\tt equals} should be a
boolean that indicates whether the cards are the same.  It is
also clear that there have to be two {\tt Card}s as parameters.
But we have one more choice: should {\tt equals} be a member
function or a free-standing function?

As a member function, it looks like this:

\begin{verbatim}
bool Card::equals (const Card& c2) const
{
  return (rank == c2.rank && suit == c2.suit);
}
\end{verbatim}
%
To use this function, we have to invoke it on one of the
cards and pass the other as an argument:

\begin{verbatim}
  Card card1 (1, 11);
  Card card2 (1, 11);

  if (card1.equals(card2)) {
    cout << "Yup, that's the same card." << endl;
  }
\end{verbatim}
%
This method of invocation always seems strange to me when the
function is something like {\tt equals}, in which the two
arguments are symmetric.  What I mean by symmetric is that it
does not matter whether I ask ``Is A equal to B?'' or
``Is B equal to A?''  In this case, I think it looks better to rewrite
{\tt equals} as a nonmember function:

\begin{verbatim}
bool equals (const Card& c1, const Card& c2)
{
  return (c1.rank == c2.rank && c1.suit == c2.suit);
}
\end{verbatim}
%
When we call this version of the function, the arguments
appear side-by-side in a way that makes more logical sense,
to me at least.

\begin{verbatim}
  if (equals (card1, card2)) {
    cout << "Yup, that's the same card." << endl;
  }
\end{verbatim}
%
Of course, this is a matter of taste.  My point here is that
you should be comfortable writing both member and nonmember
functions, so that you can choose the interface that works best
depending on the circumstance.

\section{The {\tt isGreater} function}
\index{isGreater}
\index{operator!comparison}
\index{comparison operator}

For basic types like {\tt int} and {\tt double}, there are comparison
operators that compare values and determine when one is greater or
less than another.  These operators ({\tt <} and {\tt >} and the
others) don't work for user-defined types.  Just as we did for the
{\tt ==} operator, we will write a comparison function that plays
the role of the {\tt >} operator.  Later, we will use this function to
sort a deck of cards.

\index{ordering}
\index{complete ordering}
\index{partial ordering}

Some sets are totally ordered, which means that you can compare any
two elements and tell which is bigger.  For example, the integers and
the floating-point numbers are totally ordered.  Some sets are
unordered, which means that there is no meaningful way to say that one
element is bigger than another.  For example, the fruits are
unordered, which is why we cannot compare apples and oranges.  As
another example, the {\tt bool} type is unordered; we cannot say that
{\tt true} is greater than {\tt false}.

The set of playing cards is partially ordered, which means that
sometimes we can compare cards and sometimes not.  For example, I know
that the 3 of Clubs is higher than the 2 of Clubs because it has
higher rank, and the 3 of Diamonds is higher than the 3 of Clubs
because it has higher suit.  But which is better, the 3 of Clubs or
the 2 of Diamonds?  One has a higher rank, but the other has a higher
suit.

\index{comparable}

In order to make cards comparable, we have to decide which is more
important, rank or suit.  To be honest, the choice is completely
arbitrary.  For the sake of choosing, I will say that suit is more
important, because when you buy a new deck of cards, it comes sorted
with all the Clubs together, followed by all the Diamonds, and so on.

With that decided, we can write {\tt isGreater}.  Again, the arguments
(two {\tt Card}s) and the return type (boolean) are obvious, and again
we have to choose between a member function and a nonmember function.
This time, the arguments are not symmetric.  It matters whether we
want to know ``Is A greater than B?'' or ``Is B greater than A?''
Therefore I think it makes more sense to write {\tt isGreater} as a
member function:

\begin{verbatim}
bool Card::isGreater (const Card& c2) const
{
  // first check the suits
  if (suit > c2.suit) return true;
  if (suit < c2.suit) return false;

  // if the suits are equal, check the ranks
  if (rank > c2.rank) return true;
  if (rank < c2.rank) return false;

  // if the ranks are also equal, return false
  return false;
}
\end{verbatim}
%
Then when we invoke it, it is obvious from the syntax which
of the two possible questions we are asking:

\begin{verbatim}
  Card card1 (2, 11);
  Card card2 (1, 11);

  if (card1.isGreater (card2)) {
    card1.print ();
    cout << "is greater than" << endl;
    card2.print ();
  }
\end{verbatim}
%
You can almost read it like English: ``If card1 isGreater card2 ...''
The output of this program is

\begin{verbatim}
Jack of Hearts
is greater than
Jack of Diamonds
\end{verbatim}
%
According to {\tt isGreater}, aces are
less than deuces (2s).
As an exercise, fix it so that aces are ranked higher than Kings,
as they are in most card games.

\section{Vectors of cards}
\index{vector!of object}
\index{object!vector of}
\index{deck}

The reason I chose {\tt Cards} as the objects for this chapter is that
there is an obvious use for a vector of cards---a deck.  Here is some
code that creates a new deck of 52 cards:

\begin{verbatim}
  apvector<Card> deck (52);
\end{verbatim}
%
Here is the state diagram for this object:

\index{state diagram}

\vspace{0.1in}
\centerline{\epsfig{figure=cardvector.eps}}
\vspace{0.1in}

The three dots represent the 48 cards I didn't feel like
drawing.  Keep in mind that we haven't initialized the instance
variables of the cards yet.  In some environments, they will get
initialized to zero, as shown in the figure, but in others they
could contain any possible value.

One way to initialize them would be to pass a {\tt Card} as
a second argument to the constructor:

\begin{verbatim}
  Card aceOfSpades (3, 1);
  apvector<Card> deck (52, aceOfSpades);
\end{verbatim}
%
This code builds a deck with 52 identical cards, like
a special deck for a magic trick.  Of course,
it makes more sense to build a deck with 52 different cards
in it.  To do that we use a nested loop.

\index{loop!nested}
\index{nested loop}

The outer loop enumerates the suits, from 0 to 3.  For
each suit, the inner loop enumerates the ranks, from 1
to 13.  Since the outer loop iterates 4 times, and
the inner loop iterates 13 times, the total number of times
the body is executed is 52 (13 times 4).

\begin{verbatim}
  int i = 0;
  for (int suit = 0; suit <= 3; suit++) {
    for (int rank = 1; rank <= 13; rank++) {
      deck[i].suit = suit;
      deck[i].rank = rank;
      i++;
    }
  }
\end{verbatim}
%
I used the variable {\tt i} to keep track of where in the
deck the next card should go.

\index{index}

Notice that we can compose the syntax for selecting an element
from an array (the {\tt []} operator) with the syntax for
selecting an instance variable from an object (the dot
operator).  The expression {\tt deck[i].suit} means 
``the suit of the ith card in the deck''.

\index{encapsulation}

As an exercise, encapsulate this deck-building code in a function called
{\tt buildDeck} that takes no parameters and that returns a
fully-populated vector of {\tt Card}s.

\section{The {\tt printDeck} function}
\label{printdeck}
\index{printDeck}
\index{print!vector of Cards}

Whenever you are working with vectors, it is convenient to have
a function that prints the contents of the vector.  We have
seen the pattern for traversing a vector several times, so the
following function should be familiar:

\begin{verbatim}
void printDeck (const apvector<Card>& deck) {
  for (int i = 0; i < deck.length(); i++) {
    deck[i].print ();
  }
}
\end{verbatim}
%
By now it should come as no surprise that we can compose the
syntax for vector access with the syntax for invoking a function.

Since {\tt deck} has type {\tt apvector<Card>}, an element of {\tt deck}
has type {\tt Card}.  Therefore, it is legal to invoke {\tt print}
on {\tt deck[i]}.

\section{Searching}
\label{find}
\index{searching}
\index{linear search}
\index{find}

The next function I want to write is {\tt find}, which searches
through a vector of {\tt Card}s to see whether it contains a certain
card.  It may not be obvious why this function would be useful, but it
gives me a chance to demonstrate two ways to go searching for things,
a {\tt linear} search and a {\tt bisection} search.

\index{traverse}
\index{loop!search}

Linear search is the more obvious of the two; it involves traversing
the deck and comparing each card to the one we are looking for.  If we
find it we return the index where the card appears.  If it is not in
the deck, we return -1.

\begin{verbatim}
int find (const Card& card, const apvector<Card>& deck) {
  for (int i = 0; i < deck.length(); i++) {
    if (equals (deck[i], card)) return i;
  }
  return -1;
}
\end{verbatim}
%
The loop here is exactly the same as the loop in {\tt printDeck}.
In fact, when I wrote the program, I copied it, which saved me
from having to write and debug it twice.

Inside the loop, we compare each element of the deck to
{\tt card}.  The function returns as soon as it discovers
the card, which means that we do not have to traverse the entire
deck if we find the card we are looking for.  If the loop terminates
without finding the card, we know the card is not in the deck
and return {\tt -1}.

\index{pattern!eureka}
\index{statement!return}
\index{return!inside loop}

To test this function, I wrote the following:

\begin{verbatim}
  apvector<Card> deck = buildDeck ();

  int index = card.find (deck[17]);
  cout << "I found the card at index = " << index << endl;
\end{verbatim}
%
The output of this code is

\begin{verbatim}
I found the card at index = 17
\end{verbatim}
%


\section{Bisection search}
\index{bisection search}

If the cards in the deck are not in order, there is no way to search
that is faster than the linear search.  We have to look at every card,
since otherwise there is no way to be certain the card we want is not
there.

But when you look for a word in a dictionary, you don't search
linearly through every word.  The reason is that the words are in
alphabetical order.  As a result, you probably use an algorithm that
is similar to a bisection search:

\begin {enumerate}

\item Start in the middle somewhere.

\item Choose a word on the page and compare it to the word you
are looking for.

\item If you found the word you are looking for, stop.

\item If the word you are looking for comes after the word on
the page, flip to somewhere later in the dictionary and go to
step 2.

\item If the word you are looking for comes before the word on
the page, flip to somewhere earlier in the dictionary and go to
step 2.

\end {enumerate}

If you ever get to the point where there are two adjacent words on the
page and your word comes between them, you can conclude that your word
is not in the dictionary.  The only alternative is that your word has
been misfiled somewhere, but that contradicts our assumption that the
words are in alphabetical order.

In the case of a deck of cards, if we know that the cards are in
order, we can write a version of {\tt find} that is much faster.  The
best way to write a bisection search is with a recursive function.
That's because bisection is naturally recursive.

\index{findBisect}

The trick is to write a function called {\tt findBisect} that takes
two indices as parameters, {\tt low} and {\tt high}, indicating the
segment of the vector that should be searched (including both
{\tt low} and {\tt high}).

\begin{enumerate}

\item To search the vector, choose an index between {\tt low} and {\tt
high}, and call it {\tt mid}.  Compare the card at {\tt mid} to the
card you are looking for.

\item If you found it, stop.

\item If the card at {\tt mid} is higher than your card, search
in the range from {\tt low} to {\tt mid-1}.

\item If the card at {\tt mid} is lower than your card, search
in the range from {\tt mid+1} to {\tt high}.

\end{enumerate}
%
Steps 3 and 4 look suspiciously like recursive
invocations.  Here's what this all looks like translated into
C++:

\begin{verbatim}
int findBisect (const Card& card, const apvector<Card>& deck,
                int low, int high) {
  int mid = (high + low) / 2;

  // if we found the card, return its index
  if (equals (deck[mid], card)) return mid;

  // otherwise, compare the card to the middle card
  if (deck[mid].isGreater (card)) {
    // search the first half of the deck
    return findBisect (card, deck, low, mid-1);
  } else {
    // search the second half of the deck
    return findBisect (card, deck, mid+1, high);
  }
}
\end{verbatim}
%
Although this code contains the kernel of a bisection search, it
is still missing a piece.  As it is currently written,
if the card is not in the deck, it will recurse forever.  We
need a way to detect this condition and deal with it properly
(by returning {\tt -1}).

\index{recursion}

The easiest way to tell that your card is not in the deck
is if there are {\em no} cards in the deck, which is the
case if {\tt high} is less than {\tt low}.  Well, there are
still cards in the deck, of course, but what I mean is that
there are no cards in the segment of the deck indicated by
{\tt low} and {\tt high}.

With that line added, the function works correctly:

\begin{verbatim}
int findBisect (const Card& card, const apvector<Card>& deck,
                int low, int high) {

  cout << low << ", " << high << endl;

  if (high < low) return -1;

  int mid = (high + low) / 2;

  if (equals (deck[mid], card)) return mid;

  if (deck[mid].isGreater (card)) {
    return findBisect (card, deck, low, mid-1);
  } else {
    return findBisect (card, deck, mid+1, high);
  }
}
\end{verbatim}
%
I added an output statement at the beginning so I could watch
the sequence of recursive calls and convince myself
that it would eventually reach the base case.  I tried out the
following code:

\begin{verbatim}
  cout << findBisect (deck, deck[23], 0, 51));
\end{verbatim}
%
And got the following output:

\begin{verbatim}
0, 51
0, 24
13, 24
19, 24
22, 24
I found the card at index = 23
\end{verbatim}
%
Then I made up a card that is not in the deck (the 15 of Diamonds),
and tried to find it.  I got the following:

\begin{verbatim}
0, 51
0, 24
13, 24
13, 17
13, 14
13, 12
I found the card at index = -1
\end{verbatim}
%
These tests don't prove that this program is correct.  In fact, no
amount of testing can prove that a program is correct.  On the other
hand, by looking at a few cases and examining the code, you might be
able to convince yourself.

\index{testing}
\index{correctness}

The number of recursive calls is fairly small, typically 6 or 7.  That
means we only had to call {\tt equals} and {\tt isGreater} 6 or 7
times, compared to up to 52 times if we did a linear search.  In
general, bisection is much faster than a linear search, especially for
large vectors.

Two common errors in recursive programs are forgetting to include a
base case and writing the recursive call so that the base case is never
reached.  Either error will cause an infinite recursion, in which case
C++ will (eventually) generate a run-time error.

\index{recursion!infinite}
\index{infinite recursion}
\index{run-time error}

\section{Decks and subdecks}
\index{deck}
\index{subdeck}

Looking at the interface to {\tt findBisect}

\begin{verbatim}
int findBisect (const Card& card, const apvector<Card>& deck,
		int low, int high) {
\end{verbatim}
%
it might make sense to treat three of the parameters, {\tt deck}, {\tt
low} and {\tt high}, as a single parameter that specifies a {\bf
subdeck}.

\index{parameter!abstract}
\index{abstract parameter}

This kind of thing is quite common, and I sometimes think of it as an
{\bf abstract parameter}.  What I mean by ``abstract,'' is something
that is not literally part of the program text, but which describes the
function of the program at a higher level.

For example, when you call a function and pass a vector and the bounds
{\tt low} and {\tt high}, there is nothing that prevents the called
function from accessing parts of the vector that are out of bounds.  So
you are not literally sending a subset of the deck; you are really
sending the whole deck.  But as long as the recipient plays by the
rules, it makes sense to think of it, abstractly, as a subdeck.

There is one other example of this kind of abstraction that you might
have noticed in Section~\ref{objectops}, when I referred to an
``empty'' data structure.  The reason I put ``empty'' in quotation
marks was to suggest that it is not literally accurate.  All variables
have values all the time.  When you create them, they are given
default values.  So there is no such thing as an empty object.

But if the program guarantees that the current value of a variable is
never read before it is written, then the current value is irrelevant.
Abstractly, it makes sense to think of such a variable as ``empty.''

This kind of thinking, in which a program comes to take on meaning
beyond what is literally encoded, is a very important part of thinking
like a computer scientist.  Sometimes, the word ``abstract'' gets used
so often and in so many contexts that it is hard to interpret.
Nevertheless, abstraction is a central idea in computer science (as
well as many other fields).

\index{abstraction}

A more general definition of ``abstraction'' is ``The process of
modeling a complex system with a simplified description in order to
suppress unnecessary details while capturing relevant behavior.''

\section{Glossary}

\begin{description}

\item[encode:]  To represent one set of values using another
set of values, by constructing a mapping between them.

\item[abstract parameter:]  A set of parameters that act together
as a single parameter.

\index{encode}
\index{abstract parameter}

\end{description}


% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{Objects of Vectors}

\section{Enumerated types}
\index{type!enumerated}
\index{enumerated type}
\index{mapping}

In the previous chapter I talked about mappings between
real-world values like rank and suit, and internal representations
like integers and strings.  Although we created a mapping between
ranks and integers, and between suits and integers, I pointed
out that the mapping itself does not appear as part of the
program.

Actually, C++ provides a feature called and {\bf enumerated type}
that makes it possible to (1) include a mapping as part of the
program, and (2) define the set of values that make up the
mapping.  For example, here is the definition
of the enumerated types {\tt Suit} and {\tt Rank}:

\begin{verbatim}
enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };

enum Rank { ACE=1, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE,
TEN, JACK, QUEEN, KING };
\end{verbatim}
%
By default, the first value in the enumerated type maps to
0, the second to 1, and so on.  Within the {\tt Suit} type, the value
{\tt CLUBS} is represented by the integer 0, {\tt DIAMONDS} is
represented by 1, etc.

The definition of {\tt Rank} overrides the default mapping and
specifies that {\tt ACE} should be represented by the integer 1.
The other values follow in the usual way.

Once we have defined these types, we can use them anywhere.  For
example, the instance variables {\tt rank} and {\tt suit} are
can be declared with type {\tt Rank} and {\tt Suit}:

\begin{verbatim}
struct Card
{
  Rank rank;
  Suit suit;

  Card (Suit s, Rank r);
};
\end{verbatim}
%
That the types of the parameters for the constructor
have changed, too.  Now, to create a card, we can use the values from
the enumerated type as arguments:

\begin{verbatim}
  Card card (DIAMONDS, JACK);
\end{verbatim}
%
By convention, the values in enumerated types have names with
all capital letters. \index{convention}
This code is much clearer than the alternative using integers:

\begin{verbatim}
  Card card (1, 11);
\end{verbatim}
%
Because we know that the values in the enumerated types are
represented as integers, we can use them as indices for a vector.
Therefore the old {\tt print} function will work without
modification.  We have to make some changes in {\tt buildDeck},
though:

\begin{verbatim}
  int index = 0;
  for (Suit suit = CLUBS; suit <= SPADES; suit = Suit(suit+1)) {
    for (Rank rank = ACE; rank <= KING; rank = Rank(rank+1)) {
      deck[index].suit = suit;
      deck[index].rank = rank;
      index++;
    }
  }
\end{verbatim}
%
In some ways, using enumerated types makes this code more readable,
but there is one complication.  Strictly speaking, we are not
allowed to do arithmetic with enumerated types, so {\tt suit++}
is not legal.  On the other hand, in the expression {\tt suit+1},
C++ automatically converts the enumerated type to integer.  Then
we can take the result and typecast it back to the enumerated type:

\begin{verbatim}
  suit = Suit(suit+1);
  rank = Rank(rank+1);
\end{verbatim}
%
Actually, there is a better way to do this---we can define
the {\tt ++} operator for enumerated types---but that is beyond
the scope of this book.

\section{{\tt switch} statement}
\index{switch statement}
\index{statement!switch}

It's hard to mention enumerated types without mentioning {\tt switch}
statements, because they often go hand in hand.  A {\tt switch} statement
is an alternative to a chained conditional that is syntactically
prettier and often more efficient.  It looks like this:

\begin{verbatim}
  switch (symbol) {
  case '+':
    perform_addition ();
    break;
  case '*':
    perform_multiplication ();
    break;
  default:
    cout << "I only know how to perform addition and multiplication" << endl;
    break;
  }
\end{verbatim}
%
This {\tt switch} statement is equivalent to the following chained
conditional:

\begin{verbatim}
  if (symbol == '+') {
    perform_addition ();
  } else if (symbol == '*') {
    perform_multiplication ();
  } else {
    cout << "I only know how to perform addition and multiplication" << endl;
  }
\end{verbatim}
%
The {\tt break} statements are necessary in each branch
in a {\tt switch} statement because otherwise the flow of execution
``falls through'' to the next case.  Without the {\tt break} statements,
the symbol {\tt +} would make the program perform addition, and
then perform multiplication, and then print the error message.
Occasionally this feature is useful, but most of the time it is
a source of errors when people forget the {\tt break} statements.

\index{break statement}
\index{statement!break}

{\tt switch} statements work with integers, characters, and enumerated
\mbox{types}.  For example, to convert a {\tt Suit} to the corresponding
string, we could use something like:

\begin{verbatim}
  switch (suit) {
  case CLUBS:     return "Clubs";
  case DIAMONDS:  return "Diamonds";
  case HEARTS:    return "Hearts";
  case SPADES:    return "Spades";
  default:        return "Not a valid suit";
  }
\end{verbatim}
%
In this case we don't need {\tt break} statements because the
{\tt return} statements cause the flow of execution to return to
the caller instead of falling through to the next case.

\index{default}

In general it is good style to include a {\tt default} case in
every {\tt switch} statement, to handle errors or unexpected values.

\section{Decks}
\label{deck}
\index{deck}
\index{vector!of Cards}

In the previous chapter, we worked with a vector of objects,
but I also mentioned that it is possible to have an object
that contains a vector as an instance variable.  In this
chapter I am going to create a new object, called a {\tt Deck},
that contains a vector of {\tt Card}s.

\index{instance variable}
\index{variable!instance}

The structure definition looks like this

\begin{verbatim}
struct Deck {
  apvector<Card> cards;

  Deck (int n);
};

Deck::Deck (int size)
{
  apvector<Card> temp (size);
  cards = temp;
}
\end{verbatim}
%
The name of the instance variable is {\tt cards} to help
distinguish the {\tt Deck} object from the vector of {\tt Card}s
that it contains.

\index{constructor}

For now there is only one constructor.  It creates a local variable
named {\tt temp}, which it initializes by invoking the constructor
for the {\tt apvector} class, passing the size as a parameter.
Then it copies the vector from {\tt temp} into the instance
variable {\tt cards}.

Now we can create a deck of cards like this:

\begin{verbatim}
  Deck deck (52);
\end{verbatim}
%
Here is a state diagram showing what a
{\tt Deck} object looks like:

\index{state diagram}
\index{constructor}

\vspace {0.1in}
\centerline{\epsfig{figure=deckobject.eps}}
\vspace {0.1in}

The object named {\tt deck} has a single instance variable named {\tt
cards}, which is a vector of {\tt Card} objects.  To access the cards
in a deck we have to compose the syntax for accessing an
instance variable and the syntax for selecting an element from an
array.  For example, the expression {\tt deck.cards[i]} is the ith
card in the deck, and {\tt deck.cards[i].suit} is its suit.
The following loop

\begin{verbatim}
  for (int i = 0; i<52; i++) {
    deck.cards[i].print();
  }
\end{verbatim}
%
demonstrates how to traverse the deck and output each card.

\section {Another constructor}
\index{constructor}

Now that we have a {\tt Deck} object, it would be useful
to initialize the cards in it.  From the previous chapter we
have a function called {\tt buildDeck} that we could use
(with a few adaptations), but it might be more natural to
write a second {\tt Deck} constructor.

\index{loop!nested}

\begin{verbatim}
Deck::Deck ()
{
  apvector<Card> temp (52);
  cards = temp;

  int i = 0;
  for (Suit suit = CLUBS; suit <= SPADES; suit = Suit(suit+1)) {
    for (Rank rank = ACE; rank <= KING; rank = Rank(rank+1)) {
      cards[i].suit = suit;
      cards[i].rank = rank;
      i++;
    }
  }
}
\end{verbatim}
%
Notice how similar this function is to {\tt buildDeck}, except
that we had to change the syntax to make it a constructor.
Now we can create a standard 52-card deck with the simple
declaration {\tt Deck deck;}

\section {{\tt Deck} member functions}
\index{member function}
\index{function!member}

Now that we have a {\tt Deck} object, it makes sense to put
all the functions that pertain to {\tt Deck}s in the {\tt Deck}
structure definition.  Looking at the functions we have written so
far, one obvious candidate is {\tt printDeck} (Section~\ref{printdeck}).
Here's how it looks, rewritten as a {\tt Deck} member function:

\index{printDeck}

\begin{verbatim}
void Deck::print () const {
  for (int i = 0; i < cards.length(); i++) {
    cards[i].print ();
  }
}
\end{verbatim}
%
As usual, we can refer to the instance variables of the current
object without using dot notation.

For some of the other functions, it is not obvious whether they should
be member functions of {\tt Card}, member functions of {\tt Deck}, or
nonmember functions that take {\tt Card}s and {\tt Deck}s as parameters.
For example, the version of {\tt find} in the previous chapter
takes a {\tt Card} and a {\tt Deck} as arguments, but you could
reasonably make it a member function of either type.  As an exercise,
rewrite {\tt find} as a {\tt Deck} member function that takes
a {\tt Card} as a parameter.

Writing {\tt find} as a {\tt Card} member
function is a little tricky.  Here's my version:

\begin{verbatim}
int Card::find (const Deck& deck) const {
  for (int i = 0; i < deck.cards.length(); i++) {
    if (equals (deck.cards[i], *this)) return i;
  }
  return -1;
}
\end{verbatim}
%
The first trick is that we have to use the keyword {\tt this}
to refer to the {\tt Card} the function is invoked on.

\index{structure definition}

The second trick is that C++ does not make it easy to write
structure definitions that refer to each other.  The problem
is that when the compiler is reading the first structure
definition, it doesn't know about the second one yet.

One solution is to declare {\tt Deck} before {\tt Card} and
then define {\tt Deck} afterwards:

\begin{verbatim}
// declare that Deck is a structure, without defining it
struct Deck;

// that way we can refer to it in the definition of Card
struct Card
{
  int suit, rank;

  Card ();
  Card (int s, int r);

  void print () const;
  bool isGreater (const Card& c2) const;
  int find (const Deck& deck) const;
};

// and then later we provide the definition of Deck
struct Deck {
  apvector<Card> cards;

  Deck ();
  Deck (int n);
  void print () const;
  int find (const Card& card) const;
};
\end{verbatim}


\section{Shuffling}
\label{shuffle}
\index{shuffling}

For most card games you need to be able to shuffle the deck;
that is, put the cards in a random order.  In Section~\ref{random}
we saw how to generate random numbers, but it is not obvious how
to use them to shuffle a deck.

One possibility is to model the way humans shuffle, which is usually
by dividing the deck in two and then reassembling the deck by choosing
alternately from each deck.  Since humans usually don't shuffle
perfectly, after about 7 iterations the order of the deck is pretty
well randomized.  But a computer program would have the annoying
property of doing a perfect shuffle every time, which is not really
very random.  In fact, after 8 perfect shuffles, you would find the
deck back in the same order you started in.  For a discussion of that
claim, see {\tt http://www.wiskit.com/marilyn/craig.html} or do a web
search with the keywords ``perfect shuffle.''

A better shuffling algorithm is to traverse the deck one card at a
time, and at each iteration choose two cards and swap them.

\index{pseudocode}

Here is an outline of how this algorithm works.  To sketch the
program, I am using a combination of C++ statements and English
words that is sometimes called {\bf pseudocode}:

\begin{verbatim}
  for (int i=0; i<cards.length(); i++) {
    // choose a random number between i and cards.length()
    // swap the ith card and the randomly-chosen card
  }
\end{verbatim}
%
The nice thing about using pseudocode is that it often makes it
clear what functions you are going to need.  In this case, we
need something like {\tt randomInt}, which chooses a random
integer between the parameters {\tt low} and {\tt high},
and {\tt swapCards} which takes two indices and switches the
cards at the indicated positions.

\index{random number}

You can probably figure out how to write {\tt randomInt}
by looking at Section~\ref{random}, although you will have to
be careful about possibly generating indices that are out of range.

\index{swapCards}
\index{reference}

You can also figure out {\tt swapCards} yourself.
I will leave the remaining implementation of these functions
as an exercise to the reader.

\section{Sorting}
\label{sorting}
\index{sorting}

Now that we have messed up the deck, we need a way to put it
back in order.  Ironically, there is an algorithm for
sorting that is very similar to the algorithm for shuffling.

Again, we are going to traverse the deck and at each location
choose another card and swap.  The only difference is that
this time instead of choosing the other card at random, we
are going to find the lowest card remaining in the deck.

By ``remaining in the deck,'' I mean cards that are at or
to the right of the index {\tt i}.

\begin{verbatim}
  for (int i=0; i<cards.length(); i++) {
    // find the lowest card at or to the right of i
    // swap the ith card and the lowest card
  }
\end{verbatim}
%
Again, the pseudocode helps with the design of the {\bf helper
functions}.  In this case we can use {\tt swapCards} again,
so we only need one new one, called {\tt findLowestCard},
that takes a vector of cards and an index where it should
start looking.

This process, using pseudocode to figure out what helper
functions are needed, is sometimes called {\bf top-down
design}, in contrast to the bottom-up design I discussed
in Section~\ref{counting}.

\index{top-down design}
\index{program development!top-down}
\index{bottom-up design}
\index{program development!bottom-up}
\index{helper function}
\index{function!helper}

Once again, I am going to leave the implementation up to
the reader.

\section {Subdecks}
\index{subdeck}

How should we represent a hand or some other subset of a full deck?
One easy choice is to make a {\tt Deck} object that
has fewer than 52 cards.

We might want a function, {\tt subdeck}, that takes a vector of cards
and a range of indices, and that returns a new vector of cards that
contains the specified subset of the deck:

\begin{verbatim}
Deck Deck::subdeck (int low, int high) const {
  Deck sub (high-low+1);
	
  for (int i = 0; i<sub.cards.length(); i++) {
    sub.cards[i] = cards[low+i];
  }
  return sub;
}
\end{verbatim}
%
To create the local variable named {\tt subdeck} we are using
the {\tt Deck} constructor that takes the size of the deck
as an argument and that does not initialize the cards.  The
cards get initialized when they are copied from the original
deck.

The length of the subdeck is {\tt high-low+1} because both the low
card and high card are included.  This sort of computation can be
confusing, and lead to ``off-by-one'' errors.  Drawing a picture is
usually the best way to avoid them.

\index{constructor}
\index{overloading}

As an exercise, write a version of {\tt findBisect} that takes a
subdeck as an argument, rather than a deck and an index range.  Which
version is more error-prone?  Which version do you think is more
efficient?

\section{Shuffling and dealing}
\index{shuffling}
\index{dealing}

In Section~\ref{shuffle} I wrote pseudocode for a shuffling algorithm.
Assuming that we have a function called {\tt shuffleDeck} that takes
a deck as an argument and shuffles it, we can create and shuffle
a deck:

\begin{verbatim}
  Deck deck;               // create a standard 52-card deck
  deck.shuffle ();         // shuffle it
\end{verbatim}
%
Then, to deal out several hands, we can use {\tt subdeck}:

\begin{verbatim}
  Deck hand1 = deck.subdeck (0, 4);
  Deck hand2 = deck.subdeck (5, 9);
  Deck pack = deck.subdeck (10, 51);
\end{verbatim}
%
This code puts the first 5 cards in one hand, the next 5 cards
in the other, and the rest into the pack.

When you thought about dealing, did you think we should give out one
card at a time to each player in the round-robin style that is common
in real card games?  I thought about it, but then realized that it is
unnecessary for a computer program.  The round-robin convention is
intended to mitigate imperfect shuffling and make it more difficult
for the dealer to cheat.  Neither of these is an issue for a computer.

This example is a useful reminder of one of the dangers of engineering
metaphors: sometimes we impose restrictions on computers that are
unnecessary, or expect capabilities that are lacking, because we
unthinkingly extend a metaphor past its breaking point.  Beware of
misleading analogies.


\section {Mergesort}
\index{efficiency}
\index{sorting}
\index{mergesort}

In Section~\ref{sorting}, we saw a simple sorting algorithm that turns
out not to be very efficient.  In order to sort $n$ items, it has to
traverse the vector $n$ times, and each traversal takes an amount of
time that is proportional to $n$.  The total time, therefore, is
proportional to $n^2$.

In this section I will sketch a more efficient algorithm called {\bf
mergesort}.  To sort $n$ items, mergesort takes time proportional to
$n \log n$.  That may not seem impressive, but as $n$ gets big, the
difference between $n^2$ and $n \log n$ can be enormous.  Try out a
few values of $n$ and see.

The basic idea behind mergesort is this: if you have two subdecks,
each of which has been sorted, it is easy (and fast) to merge them
into a single, sorted deck.  Try this out with a deck of cards:

\begin{enumerate}

\item Form two subdecks with about 10 cards each and sort
them so that when they are face up the lowest cards are on
top.  Place both decks face up in front of you.

\item Compare the top card from each deck and choose the
lower one.  Flip it over and add it to the merged deck.

\item Repeat step two until one of the decks is empty.
Then take the remaining cards and add them to the merged
deck.

\end{enumerate}

The result should be a single sorted deck.  Here's what this
looks like in pseudocode:

\begin{verbatim}
  Deck merge (const Deck& d1, const Deck& d2) {
    // create a new deck big enough for all the cards
    Deck result (d1.cards.length() + d2.cards.length());

    // use the index i to keep track of where we are in
    // the first deck, and the index j for the second deck
    int i = 0;
    int j = 0;
		
    // the index k traverses the result deck
    for (int k = 0; k<result.cards.length(); k++) {
			
      // if d1 is empty, d2 wins; if d2 is empty, d1 wins;
      // otherwise, compare the two cards
			
      // add the winner to the new deck
    }
    return result;
  }
\end{verbatim}
%
I chose to make {\tt merge} a nonmember function because
the two arguments are symmetric.

The best way to test {\tt merge} is to build and shuffle a deck,
use subdeck to form two (small) hands, and then use the sort
routine from the previous chapter to sort the two halves.  Then
you can pass the two halves to {\tt merge} to see if it works.

\index{testing}

If you can get that working, try a simple implementation of
{\tt mergeSort}:

\begin{verbatim}
Deck Deck::mergeSort () const {
  // find the midpoint of the deck
  // divide the deck into two subdecks
  // sort the subdecks using sort
  // merge the two halves and return the result
}
\end{verbatim}
%
Notice that the current object is declared {\tt const} because
{\tt mergeSort} does not modify it.  Instead, it creates and
returns a new {\tt Deck} object.

If you get that version working, the real fun begins!  The magical thing
about mergesort is that it is recursive.  At the point where you sort
the subdecks, why should you invoke the old, slow version of {\tt
sort}?  Why not invoke the spiffy new {\tt mergeSort} you are in the
process of writing?

\index{recursion}

Not only is that a good idea, it is {\em necessary} in order to
achieve the performance advantage I promised.  In order to make it
work, though, you have to add a base case so that it doesn't recurse
forever.  A simple base case is a subdeck with 0 or 1 cards.  If {\tt
mergesort} receives such a small subdeck, it can return it
unmodified, since it is already sorted.

The recursive version of {\tt mergesort} should look something
like this:

\begin{verbatim}
Deck Deck::mergeSort (Deck deck) const {
  // if the deck is 0 or 1 cards, return it

  // find the midpoint of the deck
  // divide the deck into two subdecks
  // sort the subdecks using mergesort
  // merge the two halves and return the result
}
\end{verbatim}
%
As usual, there are two ways to think about recursive programs:
you can think through the entire flow of execution, or you
can make the ``leap of faith.''  I have deliberately constructed
this example to encourage you to make the leap of faith.

\index{leap of faith}

When you were using {\tt sort} to sort the subdecks, you didn't
feel compelled to follow the flow of execution, right?  You just
assumed that the {\tt sort} function would work because you already
debugged it.  Well, all you did to make {\tt mergeSort} recursive was
replace one sort algorithm with another.  There is no reason to read
the program differently.

Well, actually you have to give some thought to getting the
base case right and making sure that you reach it eventually,
but other than that, writing the recursive version should be
no problem.  Good luck!

\section{Glossary}

\begin{description}

\item[pseudocode:]  A way of designing programs by writing
rough drafts in a combination of English and C++.

\item[helper function:]  Often a small function that does not
do anything enormously useful by itself, but which helps
another, more useful, function.

\item[bottom-up design:]  A method of program development that
uses pseudocode to sketch solutions to large problems and
design the interfaces of helper functions.

\item[mergesort:]  An algorithm for sorting a collection of
values.  Mergesort is faster than the simple algorithm in
the previous chapter, especially for large collections.

\index{pseudocode}
\index{helper function}
\index{bottom-up design}
\index{program development!bottom-up}
\index{function!helper}
\index{mergesort}


\end{description}

% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{Classes and invariants}
\label{class}

\section{Private data and classes}
\index{private}
\index{class}
\index{data encapsulation}
\index{encapsulation!data}
\index{encapsulation!functional}

I have used the word ``encapsulation'' in this book to refer
to the process of wrapping up a sequence of instructions in
a function, in order to separate the function's interface (how
to use it) from its implementation (how it does what it does).

This kind of encapsulation might be called ``functional
encapsulation,'' to distinguish it from ``data encapsulation,'' which
is the topic of this chapter.  Data encapsulation is based on the idea
that each structure definition should provide a set of functions that
apply to the structure, and prevent unrestricted access to the
internal representation.

\index{interface}
\index{implementation}
\index{representation}

One use of data encapsulation is to hide implementation details 
from users or programmers that don't need to know them.

For example, there are many possible representations for a {\tt Card},
including two integers, two strings and two enumerated types.  The
programmer who writes the {\tt Card} member functions needs to
know which implementation to use, but
someone using
the {\tt Card} structure should not have to know anything about
its internal structure.

As another example, we have been using {\tt apstring} and
{\tt apvector} objects without ever discussing their implementations.
There are many possibilities, but as ``clients'' of these
libraries, we don't need to know.

\index{client programs}
\index{detail hiding}

In C++, the most common way to enforce data encapsulation is
to prevent client programs from accessing the instance variables
of an object.  The keyword {\tt private} is used to protect parts
of a structure definition.  For example, we could have written
the {\tt Card} definition:

\begin{verbatim}
struct Card
{
private:
  int suit, rank;

public:
  Card ();
  Card (int s, int r);

  int getRank () const { return rank; }
  int getSuit () const { return suit; }
  void setRank (int r) { rank = r; }
  void setSuit (int s) { suit = s; }
};
\end{verbatim}
%
There are two sections of this definition, a private part and
a public part.  The functions are public, which means that they
can be invoked by client programs.  The instance variables are
private, which means that they can be read and written only by
{\tt Card} member functions.

\index{accessor function}
\index{function!accessor}

It is still possible for client programs to read and
write the instance variables using the {\bf accessor functions}
(the ones beginning with {\tt get} and {\tt set}).
On the other hand, it is now easy to control which
operations clients can perform on which instance variables.
For example, it might be a good idea to make cards ``read only''
so that after they are constructed, they cannot be changed.
To do that, all we have to do is remove the {\tt set} functions.

Another advantage of using accessor functions is that we
can change the internal representations of cards without
having to change any client programs.

\section{What is a class?}
\index{class}
\index{struct}
\index{object-oriented programming}

In most object-oriented programming languages, a {\bf class} is
a user-defined type that includes a set of functions.  As
we have seen, structures in C++ meet the general definition of
a class.

But there is another feature in C++ that also meets this definition;
confusingly, it is called a {\tt class}.  In C++, a class
is just a structure whose instance variables are private by
default.  For example, I could have written the {\tt Card}
definition:

\begin{verbatim}
class Card
{
  int suit, rank;

public:
  Card ();
  Card (int s, int r);

  int getRank () const { return rank; }
  int getSuit () const { return suit; }
  int setRank (int r) { rank = r; }
  int setSuit (int s) { suit = s; }
};
\end{verbatim}
%
I replaced the word {\tt struct} with the word {\tt class} and
removed the {\tt private:} label.  This result of the two definitions
is exactly the same.

\index{public}
\index{private}

In fact, anything that can be written as a {\tt struct} can also
be written as a {\tt class}, just by adding or removing labels.
There is no real reason to choose one over the other, except that
as a stylistic choice, most C++ programmers use {\tt class}.

Also, it is common to refer to all user-defined types in C++ as
``classes,'' regardless of whether they are defined as a {\tt struct}
or a {\tt class}.

\section{Complex numbers}
\index{complex number}
\index{Complex}
\index{class!Complex}
\index{arithmetic!complex}

As a running example for the rest of this chapter we will consider a
class definition for complex numbers.  Complex numbers are useful for
many branches of mathematics and engineering, and many computations
are performed using complex arithmetic.  A complex number is the sum
of a real part and an imaginary part, and is usually written in the
form $x + yi$, where $x$ is the real part, $y$ is the imaginary part,
and $i$ represents the square root of -1.

The following is a class definition for a user-defined type called
{\tt Complex}:

\begin{verbatim}
class Complex
{
  double real, imag;

public:
  Complex () { }
  Complex (double r, double i) { real = r;  imag = i; }
};
\end{verbatim}
%
Because this is a {\tt class} definition, the instance variables
{\tt real} and {\tt imag} are private, and we have to include
the label {\tt public:} to allow client code to invoke the
constructors.

As usual, there are two constructors: one takes no parameters and does
nothing; the other takes two parameters and uses them to initialize
the instance variables.

\index{instance variable}
\index{variable!instance}
\index{constructor}

So far there is no real advantage to making the instance
variables private.  Let's make things a little more complicated;
then the point might be clearer.

\index{coordinate}
\index{coordinate!Cartesian}
\index{coordinate!polar}
\index{Cartesian coordinate}
\index{polar coordinate}

There is another common representation for complex numbers that is
sometimes called ``polar form'' because it is based on polar
coordinates.  Instead of specifying the real part and the imaginary
part of a point in the complex plane, polar coordinates specify the
direction (or angle) of the point relative to the origin, and
the distance (or magnitude) of the point.  

The following figure shows the two coordinate systems graphically.

\vspace {0.1in}
\centerline{\epsfig{figure=coordinates.eps}}
\vspace {0.1in}

Complex numbers in polar coordinates are written $r e^{i \theta}$,
where $r$ is the magnitude (radius), and $\theta$ is the angle in
radians.

Fortunately, it is easy to convert from one form to another.
To go from Cartesian to polar,

\begin{eqnarray*}
r       & = &  \sqrt{x^2 + y^2} \\
\theta  & = &  \arctan (y / x)
\end{eqnarray*}

To go from polar to Cartesian,

\begin{eqnarray*}
x       & = &  r \cos \theta \\
y       & = &  r \sin \theta
\end{eqnarray*}

So which representation should we use?  Well, the whole reason there
are multiple representations is that some operations are easier to
perform in Cartesian coordinates (like addition), and others are
easier in polar coordinates (like multiplication).  One option is that
we can write a class definition that uses {\em both} representations,
and that converts between them automatically, as needed.

\begin{verbatim}
class Complex
{
  double real, imag;
  double mag, theta;
  bool cartesian, polar;

public:
  Complex () { cartesian = false;  polar = false; }

  Complex (double r, double i)
  {
    real = r;  imag = i;
    cartesian = true;  polar = false;
  }
};
\end{verbatim}
%
There are now six instance variables, which means that
this representation will take up more space than either
of the others, but we will see that it is very versatile.

\index{instance variable}
\index{variable!instance}

Four of the instance variables are self-explanatory.  They
contain the real part, the imaginary part, the angle and
the magnitude of the complex number.  The other two
variables, {\tt cartesian} and {\tt polar} are flags that
indicate whether the corresponding values are currently
valid.

\index{flag}
\index{constructor}

For example, the do-nothing constructor sets both flags
to false to indicate that this object does not contain
a valid complex number (yet), in either representation.

The second constructor uses the parameters to initialize
the real and imaginary parts, but it does not calculate the
magnitude or angle.  Setting the {\tt polar} flag to false
warns other functions not to access {\tt mag} or {\tt theta}
until they have been set.

Now it should be clearer why we need to keep the instance
variables private.  If client programs were allowed unrestricted
access, it would be easy for them to make errors by reading
uninitialized values.  In the next few sections, we will
develop accessor functions that will make those kinds of mistakes
impossible.

\section{Accessor functions}
\index{accessor function}
\index{function!accessor}

By convention, accessor functions have names that
begin with {\tt get} and end with the name of the instance
variable they fetch.  The return type, naturally, is the type
of the corresponding instance variable.

\index{flag}

In this case, the accessor functions give us an opportunity
to make sure that the value of the variable is valid before
we return it.  Here's what {\tt getReal} looks like:

\begin{verbatim}
double Complex::getReal ()
{
  if (cartesian == false) calculateCartesian ();
  return real;
}
\end{verbatim}
%
If the {\tt cartesian} flag is true then {\tt real} contains
valid data, and we can just return it.  Otherwise, we have
to call {\tt calculateCartesian} to convert from polar coordinates
to Cartesian coordinates:

\begin{verbatim}
void Complex::calculateCartesian ()
{
  real = mag * cos (theta);
  imag = mag * sin (theta);
  cartesian = true;
}
\end{verbatim}
%
Assuming that the polar coordinates are valid, we
can calculate the Cartesian coordinates using the formulas
from the previous section.  Then we
set the {\tt cartesian} flag, indicating that {\tt real}
and {\tt imag} now contain valid data.

As an exercise, write a corresponding function called
{\tt calculatePolar} and then write {\tt getMag}
and {\tt getTheta}.  One unusual thing about these
accessor functions is that they are not {\tt const},
because invoking them might modify the instance variables.

\section{Output}
\index{output}

As usual when we define a new class, we want to be able to
output objects in a human-readable form.  For {\tt Complex}
objects, we could use two functions:

\begin{verbatim}
void Complex::printCartesian ()
{
  cout << getReal() << " + " << getImag() << "i" << endl;
}

void Complex::printPolar ()
{
  cout << getMag() << " e^ " << getTheta() << "i" << endl;
}
\end{verbatim}
%
The nice thing here is that we can output any {\tt Complex} object in
either format without having to worry about the representation.  Since
the output functions use the accessor functions, the program
will compute automatically any values that are needed.

The following code creates a {\tt Complex} object using the
second constructor.   Initially, it is in Cartesian format only.
When we invoke {\tt printCartesian} it accesses {\tt real} and
{\tt imag} without having to do any conversions.

\begin{verbatim}
  Complex c1 (2.0, 3.0);

  c1.printCartesian();
  c1.printPolar();
\end{verbatim}
%
When we invoke {\tt printPolar}, and {\tt printPolar} invokes
{\tt getMag}, the program is forced to convert to polar
coordinates and store the results in the instance variables.
The good news is that we only have to do the conversion
once.  When {\tt printPolar} invokes {\tt getTheta}, it will
see that the polar coordinates are valid and return {\tt theta}
immediately.

The output of this code is:

\begin{verbatim}
2 + 3i
3.60555 e^ 0.982794i
\end{verbatim}

\section{A function on {\tt Complex} numbers}
\index{pure function}

A natural operation we might want to perform on complex numbers is
addition.  If the numbers are in Cartesian coordinates, addition is
easy: you just add the real parts together and the imaginary parts
together.  If the numbers are in polar coordinates, it is easiest to
convert them to Cartesian coordinates and then add them.

Again, it is easy to deal with these cases if we use
the accessor functions:

\begin{verbatim}
Complex add (Complex& a, Complex& b)
{
  double real = a.getReal() + b.getReal();
  double imag = a.getImag() + b.getImag();
  Complex sum (real, imag);
  return sum;
}
\end{verbatim}
%
Notice that the arguments to {\tt add} are not {\tt const}
because they might be modified when we invoke the accessors.
To invoke this function, we would pass both operands as arguments:

\begin{verbatim}
  Complex c1 (2.0, 3.0);
  Complex c2 (3.0, 4.0);

  Complex sum = add (c1, c2);
  sum.printCartesian();
\end{verbatim}
%
The output of this program is

\begin{verbatim}
5 + 7i
\end{verbatim}
%


\section{Another function on {\tt Complex} numbers}
\index{pure function}

Another operation we might want is multiplication.  Unlike
addition, multiplication is easy if the numbers are in polar
coordinates and hard if they are in Cartesian coordinates
(well, a little harder, anyway).

In polar coordinates, we can just multiply the magnitudes and
add the angles.  As usual, we can use the accessor functions
without worrying about the representation of the objects.

\begin{verbatim}
Complex mult (Complex& a, Complex& b)
{
  double mag = a.getMag() * b.getMag()
  double theta = a.getTheta() + b.getTheta();
  Complex product;
  product.setPolar (mag, theta);
  return product;
}
\end{verbatim}
%
A small problem we encounter here is that we have no constructor
that accepts polar coordinates.  It would be nice to write one,
but remember that we can only overload a function (even a
constructor) if the different versions take different parameters.
In this case, we would like a second constructor that also takes
two {\tt double}s, and we can't have that.

An alternative it to provide an accessor function that {\em sets}
the instance variables.  In order to do that properly, though,
we have to make sure that when {\tt mag} and {\tt theta} are set,
we also set the {\tt polar} flag.  At the same time, we have to
make sure that the {\tt cartesian} flag is unset.  That's because
if we change the polar coordinates, the cartesian coordinates are
no longer valid.

\begin{verbatim}
void Complex::setPolar (double m, double t)
{
  mag = m;  theta = t;
  cartesian = false;  polar = true;
}
\end{verbatim}
%
As an exercise, write the corresponding function named
{\tt setCartesian}.

To test the {\tt mult} function, we can try something like:

\begin{verbatim}
  Complex c1 (2.0, 3.0);
  Complex c2 (3.0, 4.0);

  Complex product = mult (c1, c2);
  product.printCartesian();
\end{verbatim}
%
The output of this program is

\begin{verbatim}
-6 + 17i
\end{verbatim}
%
There is a lot of conversion going on in this program behind the
scenes.  When we call {\tt mult}, both arguments get converted to
polar coordinates.  The result is also in polar format, so when we
invoke {\tt printCartesian} it has to get converted back.  Really,
it's amazing that we get the right answer!


\section{Invariants}
\index{invariant}

There are several conditions we expect to be true for a proper
{\tt Complex} object.  For example, if the {\tt cartesian} flag
is set then we expect {\tt real} and {\tt imag} to contain valid
data.  Similarly, if {\tt polar} is set, we expect {\tt mag}
and {\tt theta} to be valid.  Finally, if both flags are set
then we expect the other four variables to be consistent;
that is, they should be specifying the same point in two different
formats.

These kinds of conditions are called {\tt invariants}, for the obvious
reason that they do not vary---they are always supposed to be true.
One of the ways to write good quality code that contains few bugs
is to figure out what invariants are appropriate for your classes,
and write code that makes it impossible to violate them.

\index{data encapsulation}
\index{encapsulation!data}

One of the primary things that data encapsulation is good for
is helping to enforce invariants.  The first step is to prevent
unrestricted access to the instance variables by making them
private.  Then the only way to modify the object is through
accessor functions and modifiers.  If we examine all the accessors
and modifiers, and we can show that every one of them maintains
the invariants, then we can prove that it is impossible for
an invariant to be violated.

Looking at the {\tt Complex} class, we can list the functions
that make assignments to one or more instance variables:

\begin{verbatim}
the second constructor
calculateCartesian
calculatePolar
setCartesian
setPolar
\end{verbatim}
%
In each case, it is straightforward to show that the function
maintains each of the invariants I listed.  We have to be a little
careful, though.  Notice that I said ``maintain'' the invariant.
What that means is ``If the invariant is true when the function
is called, it will still be true when the function is complete.''

That definition allows two loopholes.  First, there may be some
point in the middle of the function when the invariant is not
true.  That's ok, and in some cases unavoidable.  As long as the
invariant is restored by the end of the function, all is well.

The other loophole is that we only have to maintain the invariant
if it was true at the beginning of the function.  Otherwise, all
bets are off.  If the invariant was violated somewhere else in
the program, usually the best we can do is detect the error,
output an error message, and exit.

\section{Preconditions}
\index{precondition}
\index{postcondition}

Often when you write a function you make implicit assumptions
about the parameters you receive.  If those assumptions turn
out to be true, then everything is fine; if not, your program
might crash.

To make your programs more robust, it is a good idea to think
about your assumptions explicitly, document them as part of the
program, and maybe write code that checks them.

For example, let's take another look at {\tt calculateCartesian}.
Is there an assumption we make about the current object?  Yes,
we assume that the {\tt polar} flag is set and that {\tt mag}
and {\tt theta} contain valid data.  If that is not true, then
this function will produce meaningless results.

One option is to add a comment to the function that warns
programmers about the {\bf precondition}.

\begin{verbatim}
void Complex::calculateCartesian ()
// precondition: the current object contains valid polar coordinates
	and the polar flag is set
// postcondition: the current object will contain valid Cartesian
	coordinates and valid polar coordinates, and both the cartesian
	flag and the polar flag will be set
{
  real = mag * cos (theta);
  imag = mag * sin (theta);
  cartesian = true;
}
\end{verbatim}
%
At the same time, I also commented on the {\bf postconditions},
the things we know will be true when the function completes.

These comments are useful for people reading your programs, but
it is an even better idea to add code that {\em checks} the
preconditions, so that we can print an appropriate error message:

\begin{verbatim}
void Complex::calculateCartesian ()
{
  if (polar == false) {
    cout <<
    "calculateCartesian failed because the polar representation is invalid"
	 << endl;
    exit (1);
  }
  real = mag * cos (theta);
  imag = mag * sin (theta);
  cartesian = true;
}
\end{verbatim}
%
The {\tt exit} function causes the program to quit immediately.  The
return value is an error code that tells the system (or whoever
executed the program) that something went wrong.

\index{exit}
\index{assert}
\index{run-time error}

This kind of error-checking is so common that C++ provides
a built-in function to check preconditions and print error messages.
If you include the {\tt assert.h} header file, you get a function
called {\tt assert} that takes a boolean value (or a conditional
expression) as an argument.  As long as the argument is true,
{\tt assert} does nothing.  If the argument is false, assert
prints an error message and quits.  Here's how to use it:

\begin{verbatim}
void Complex::calculateCartesian ()
{
  assert (polar);
  real = mag * cos (theta);
  imag = mag * sin (theta);
  cartesian = true;
  assert (polar && cartesian);
}
\end{verbatim}
%
The first {\tt assert} statement checks the precondition
(actually just part of it); the second {\tt assert} statement
checks the postcondition.

In my development environment, I get the following message
when I violate an assertion:

\begin{verbatim}
Complex.cpp:63: void Complex::calculatePolar(): Assertion `cartesian' failed.
Abort
\end{verbatim}
%
There is a lot of information here to help me track down the error,
including the file name and line number of the assertion that
failed, the function name and the contents of the assert statement.


\section{Private functions}
\index{private!function}

In some cases, there are member functions that are used internally
by a class, but that should not be invoked by client programs.
For example, {\tt calculatePolar} and {\tt calculateCartesian}
are used by the accessor functions, but there is probably no
reason clients should call them directly (although it would not
do any harm).  If we wanted to protect these functions, we
could declare them {\tt private} the same way we do with instance
variables.  In that case the complete class definition for
{\tt Complex} would look like:

\begin{verbatim}
class Complex
{
private:
  double real, imag;
  double mag, theta;
  bool cartesian, polar;

  void calculateCartesian ();
  void calculatePolar ();

public:
  Complex () { cartesian = false;  polar = false; }

  Complex (double r, double i)
  {
    real = r;  imag = i;
    cartesian = true;  polar = false;
  }

  void printCartesian ();
  void printPolar ();

  double getReal ();
  double getImag ();
  double getMag ();
  double getTheta ();

  void setCartesian (double r, double i);
  void setPolar (double m, double t);
};
\end{verbatim}
%
The {\tt private} label at the beginning is not necessary,
but it is a useful reminder.

\section{Glossary}

\begin{description}

\item[class:]  In general use, a class is a user-defined type
with member functions.  In C++, a class is a structure with
private instance variables.

\item[accessor function:]  A function that provides access
(read or write) to a private instance variable.

\item[invariant:]  A condition, usually pertaining to an object, that
should be true at all times in client code, and that should be
maintained by all member functions.

\item[precondition:]  A condition that is assumed to be true at
the beginning of a function.  If the precondition is not true, the
function may not work.  It is often a good idea for functions to
check their preconditions, if possible.

\item[postcondition:]  A condition that is true at the end of a
function. 

\index{class}
\index{accessor function}
\index{invariant}
\index{precondition}
\index{postcondition}

\end{description}

% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


\chapter{File Input/Output and {\tt apmatrix}es}

In this chapter we will develop a program that reads and writes files,
parses input, and demonstrates the {\tt apmatrix} class.  We will also
implement a data structure called {\tt Set} that expands automatically
as you add elements.

Aside from demonstrating all these features, the real purpose of the
program is to generate a two-dimensional table of
the distances between cities in the United States.
The output is a table that looks like this:

\begin{verbatim}
Atlanta 0
Chicago 700     0
Boston  1100    1000    0
Dallas  800     900     1750    0
Denver  1450    1000    2000    800     0
Detroit 750     300     800     1150    1300    0
Orlando 400     1150    1300    1100    1900    1200    0
Phoenix 1850    1750    2650    1000    800     2000    2100    0
Seattle 2650    2000    3000    2150    1350    2300    3100    1450    0
        Atlanta Chicago Boston  Dallas  Denver  Detroit Orlando Phoenix Seattle
\end{verbatim}
%
The diagonal elements are all zero because that is the distance
from a city to itself.  Also, because
the distance from A to B is the same as the distance from B
to A, there is no need to print the top half of the matrix.

\section {Streams}
\index{stream}

To get input from a file or send output to a file, you have to
create an {\tt ifstream} object (for input files) or an
{\tt ofstream} object (for output files).  These objects
are defined in the header file {\tt fstream}, which you
have to include.

\index{header file}

A {\bf stream} is an abstract object that represents the flow
of data from a source like the keyboard or a file to a destination
like the screen or a file.

We have already worked with two streams: {\tt cin}, which has type
{\tt istream}, and {\tt cout}, which has type {\tt ostream}.
{\tt cin} represents the flow of data from the keyboard to
the program.  Each time the program uses the {\tt >>} operator
or the {\tt getline} function, it removes a piece of data
from the input stream.

\index{cin}
\index{cout}
\index{istream}
\index{ostream}

Similarly, when the program uses the {\tt <<} operator on
an {\tt ostream}, it adds a datum to the outgoing stream.

\section {File input}
\label{finput}
\index{file!input}
\index{ifstream}

To get data from a file, we have to create a stream that flows
from the file into the program.  
We can do that using the {\tt ifstream} constructor.

\begin{verbatim}
  ifstream infile ("file-name");
\end{verbatim}
%
The argument for this constructor is a string that
contains the name of the file you want to open.  The result
is an object named {\tt infile} that supports all the same
operations as {\tt cin}, including {\tt >>} and {\tt getline}.

\begin{verbatim}
  int x;
  apstring line;
    
  infile >> x;               // get a single integer and store in x
  getline (infile, line);    // get a whole line and store in line
\end{verbatim}
%
If we know ahead of time how much data is in a file, it is 
straightforward to write a loop that reads the entire file and
then stops.  More often, though, we want to read the entire
file, but don't know how big it is.

There are member functions for {\tt ifstreams} that check the status
of the input stream; they are called {\tt good}, {\tt eof}, {\tt fail}
and {\tt bad}.  We will use {\tt good} to make sure the file was
opened successfully and {\tt eof} to detect the ``end of file.''

\index{stream!status}
\index{good}
\index{eof}
\index{end of file}

Whenever you get data from an input stream, you don't
know whether the attempt succeeded until you check.  If the
return value from {\tt eof} is {\tt true} then we have reached
the end of the file and we know that the last attempt failed.
Here is a program that reads lines from a file and displays
them on the screen:

\begin{verbatim}
  apstring fileName = ...;
  ifstream infile (fileName.c_str());

  if (infile.good() == false) {
    cout << "Unable to open the file named " << fileName;
    exit (1);
  }

  while (true) {
    getline (infile, line);
    if (infile.eof()) break;
    cout << line << endl;
  }
\end{verbatim}
%
The function {\tt c\_str} converts an {\tt apstring} to a
native C string.  Because the {\tt ifstream} constructor
expects a C string as an argument, we have to convert
the {\tt apstring}.

\index{c\_str}
\index{C string}
\index{string!native C}

Immediately after opening the file, we invoke the {\tt good} function.
The return value is {\tt false} if the system could not open the file,
most likely because it does not exist, or you do not have permission
to read it.

\index{loop!infinite}
\index{infinite loop}

The statement {\tt while(true)} is an idiom for an infinite
loop.  Usually there will be a {\tt break} statement somewhere in
the loop so that the program does not really run forever (although
some programs do).  In this case, the {\tt break} statement allows
us to exit the loop as soon as we detect the end of file.

\index{break statement}
\index{statement!break}
\index{getline}

It is important to exit the loop between the input statement and
the output statement, so that when {\tt getline} fails at the
end of the file, we do not output the invalid data in {\tt line}.

\section{File output}
\index{file output}
\index{ofstream}

Sending output to a file is similar.  For example, we could
modify the previous program to copy lines from one file to
another.

\begin{verbatim}
  ifstream infile ("input-file");
  ofstream outfile ("output-file");

  if (infile.good() == false || outfile.good() == false) {
    cout << "Unable to open one of the files." << endl;
    exit (1);
  }

  while (true) {
    getline (infile, line);
    if (infile.eof()) break;
    outfile << line << endl;
  }
\end{verbatim}

\section{Parsing input}
\label{parsing}
\index{parsing}

In Section~\ref{formal} I defined ``parsing'' as the process of
analyzing the structure of a sentence in a natural language or a
statement in a formal language.  For example, the compiler has to
parse your program before it can translate it into machine language.

In addition, when you read input from a file or from the keyboard
you often have to parse it in order to extract the information
you want and detect errors.

For example, I have a file called {\tt distances} that contains
information about the distances between major cities in the
United States.  I got this information from a randomly-chosen
web page

\begin{verbatim}
http://www.jaring.my/usiskl/usa/distance.html
\end{verbatim}
%
so it may be wildly inaccurate, but that doesn't matter.  The
format of the file looks like this:

\begin{verbatim}
"Atlanta"       "Chicago"       700
"Atlanta"       "Boston"        1,100
"Atlanta"       "Chicago"       700
"Atlanta"       "Dallas"        800
"Atlanta"       "Denver"        1,450
"Atlanta"       "Detroit"       750
"Atlanta"       "Orlando"       400
\end{verbatim}
%
Each line of the file contains the names of two cities in quotation
marks and the distance between them in miles.  The quotation marks
are useful because they make it easy to deal with names that have
more than one word, like ``San Francisco.''

By searching for the quotation marks in a line of input, we
can find the beginning and end of each city name.
Searching for special characters like quotation marks can be a little
awkward, though, because the quotation mark is a special character
in C++, used to identify string values.

If we want to find the
first appearance of a quotation mark, we have to write something
like:

\begin{verbatim}
  int index = line.find ('\"');
\end{verbatim}
%
The argument here looks like a mess, but it represents a single
character, a double quotation mark.  The outermost single-quotes
indicate that this is a character value, as usual.  The backslash
(\verb+\+) indicates that we want to treat the next character
literally.  The sequence \verb+\"+ represents a quotation mark; the
sequence \verb+\'+ represents a single-quote.  Interestingly, the
sequence \verb+\\+ represents a single backslash.  The first backslash
indicates that we should take the second backslash seriously.

\index{special character}
\index{character!special sequence}
\index{backslash}

Parsing input lines consists of finding the beginning and
end of each city name and using
the {\tt substr} function to extract the cities and distance.
{\tt substr} is an {\tt apstring} member function;
it takes two arguments, the starting index of the substring
and the length.

\index{find}

\begin{verbatim}
void processLine (const apstring& line)
{
  // the character we are looking for is a quotation mark
  char quote = '\"';

  // store the indices of the quotation marks in a vector
  apvector<int> quoteIndex (4);

  // find the first quotation mark using the built-in find
  quoteIndex[0] = line.find (quote);

  // find the other quotation marks using the find from Chapter 7
  for (int i=1; i<4; i++) {
    quoteIndex[i] = find (line, quote, quoteIndex[i-1]+1);
  }

  // break the line up into substrings
  int len1 = quoteIndex[1] - quoteIndex[0] - 1;
  apstring city1 = line.substr (quoteIndex[0]+1, len1);
  int len2 = quoteIndex[3] - quoteIndex[2] - 1;
  apstring city2 = line.substr (quoteIndex[2]+1, len2);
  int len3 = line.length() - quoteIndex[2] - 1;
  apstring distString = line.substr (quoteIndex[3]+1, len3);

  // output the extracted information
  cout << city1 << "\t" << city2 << "\t" << distString << endl;
}
\end{verbatim}
%
Of course, just displaying the extracted information is not
exactly what we want, but it is a good starting place.

\section{Parsing numbers}
\index{parsing number}
\index{atoi}
\index{convert!to integer}

The next task is to convert the numbers in the file from strings to
integers.  When people write large numbers, they often use commas to
group the digits, as in 1,750.  Most of the time when computers write
large numbers, they don't include commas, and the built-in functions
for reading numbers usually can't handle them.  That makes the
conversion a little more difficult, but it also provides an
opportunity to write a comma-stripping function, so that's ok.  Once
we get rid of the commas, we can use the library function {\tt atoi}
to convert to integer.  {\tt atoi} is defined in the header file {\tt
cstdlib}.

\index{character!classification}
\index{isdigit}

To get rid of the commas, one option is to traverse the string and
check whether each character is a digit.  If so, we add it to the
result string.  At the end of the loop, the result string contains all
the digits from the original string, in order.

\begin{verbatim}
int convertToInt (const apstring& s)
{
  apstring digitString = "";

  for (int i=0; i<s.length(); i++) {
    if (isdigit (s[i])) {
      digitString += s[i];
    }
  }
  return atoi (digitString.c_str());
}
\end{verbatim}
%
The variable {\tt digitString} is an example of an {\bf accumulator}.  It is
similar to the counter we saw in Section~\ref{loopcount},
except that instead of getting incremented, it gets accumulates
one new character at a time, using string concatentation.

The expression

\begin{verbatim}
      digitString += s[i];
\end{verbatim}
%
is equivalent to

\begin{verbatim}
      digitString = digitString + s[i];
\end{verbatim}
%
Both statements add a single character onto the end of the existing
string.

\index{concatentation}
\index{string!concatentation}
\index{accumulator}
\index{pattern!accumulator}

Since {\tt atoi} takes a C string as a parameter, we have
to convert {\tt digitString} to a C string before passing it
as an argument.

\section{The {\tt Set} data structure}
\index{Set}
\index{data structure}

A data structure is a container for grouping a collection
of data into a single object.  We have seen some examples already,
including {\tt apstring}s, which are collections of characters,
and {\tt apvector}s which are collections on any type.

An ordered set is a collection of items with two defining
properties:

\begin{description}

\item[Ordering:] The elements of the set have indices associated
with them.  We can use these indices to identify elements of the set.

\item[Uniqueness:] No element appears in the set more than once.
If you try to add an element to a set, and it already exists, there
is no effect.

\end{description}

In addition, our implementation of an ordered set will have the
following property:

\begin{description}

\item[Arbitrary size:] As we add elements to the set, it expands
to make room for new elements.

\end{description}

Both {\tt apstring}s and {\tt apvector}s have an ordering; every
element has an index we can use to identify it.  Both none of
the data structures we have seen so far have the properties of
uniqueness or arbitrary size.

\index{ordering}

To achieve uniqueness, we have to write an {\tt add} function
that searches the set to see if it already exists.  To make the
set expand as elements are added, we can take advantage of the
{\tt resize} function on {\tt apvector}s.

Here is the beginning of a class definition for a {\tt Set}.

\begin{verbatim}
class Set {
private:
  apvector<apstring> elements;
  int numElements;

public:
  Set (int n);

  int getNumElements () const;
  apstring getElement (int i) const;
  int find (const apstring& s) const;
  int add (const apstring& s);
};

Set::Set (int n)
{
  apvector<apstring> temp (n);
  elements = temp;
  numElements = 0;
}
\end{verbatim}
%
The instance variables are an {\tt apvector} of strings and an
integer that keeps track of how many elements there are in the
set.  Keep in mind that the number of elements in the
set, {\tt numElements}, is not the same thing as the size
of the {\tt apvector}.  Usually it will be smaller.

\index{constructor}

The {\tt Set} constructor takes a single parameter, which is
the initial size of the {\tt apvector}.  The initial number
of elements is always zero.

{\tt getNumElements} and {\tt getElement} are accessor functions
for the instance variables, which are private.  {\tt numElements}
is a read-only variable, so we provide a {\tt get} function
but not a {\tt set} function.

\begin{verbatim}
int Set::getNumElements () const
{
  return numElements;
}
\end{verbatim}
%
Why do we have to prevent client programs from changing {\tt
getNumElements}?  What are the invariants for this type, and
how could a client program break an invariant.  As we look
at the rest of the {\tt Set} member function, see if you can
convince yourself that they all maintain the invariants.

\index{data encapsulation}
\index{encapsulation!data}

When we use the {\tt []} operator to access the {\tt apvector},
it checks to make sure the index is greater than or equal to zero
and less than the length of the {\tt apvector}.  To access the
elements of a set, though, we need to check a stronger condition.
The index has to be less than the number of elements, which 
might be smaller than the length of the {\tt apvector}.

\begin{verbatim}
apstring Set::getElement (int i) const
{
  if (i < numElements) {
    return elements[i];
  } else {
    cout << "Set index out of range." << endl;
    exit (1);
  }
}
\end{verbatim}
%
If {\tt getElement} gets an index that is out of range, it prints
an error message (not the most useful message, I admit), and
exits.

\index{run-time error}

The interesting functions are {\tt find} and {\tt add}.  By
now, the pattern for traversing and searching should be old
hat:

\begin{verbatim}
int Set::find (const apstring& s) const
{
  for (int i=0; i<numElements; i++) {
    if (elements[i] == s) return i;
  }
  return -1;
}
\end{verbatim}
%
So that leaves us with {\tt add}.  Often the return type for
something like {\tt add} would be void, but in this case it
might be useful to make it return the index of the element.

\begin{verbatim}
int Set::add (const apstring& s)
{
  // if the element is already in the set, return its index
  int index = find (s);
  if (index != -1) return index;

  // if the apvector is full, double its size
  if (numElements == elements.length()) {
    elements.resize (elements.length() * 2);
  }

  // add the new elements and return its index
  index = numElements;
  elements[index] = s;
  numElements++;
  return index;
}
\end{verbatim}
%
The tricky thing here is that {\tt numElements} is used in
two ways.  It is the number of elements in the set, of course,
but it is also the index of the next element to be added.

It takes a minute to convince yourself that that works, but
consider this: when the number of elements is zero, the index
of the next element is 0.  When the number of elements is
equal to the length of the {\tt apvector}, that means that the
vector is full, and we have to allocate more space (using
{\tt resize}) before we can add the new element.

\index{state diagram}

Here is a state diagram showing a {\tt Set} object that
initially contains space for 2 elements.

\vspace {0.1in}
\centerline{\epsfig{figure=set.eps,width=6in}}
\vspace {0.1in}

Now we can use the {\tt Set} class to keep track of the cities
we find in the file.  In {\tt main} we create the {\tt Set} with
an initial size of 2:

\begin{verbatim}
  Set cities (2);
\end{verbatim}
%
Then in {\tt processLine} we add both cities to the {\tt Set}
and store the index that gets returned.

\begin{verbatim}
  int index1 = cities.add (city1);
  int index2 = cities.add (city2);
\end{verbatim}
%
I modified {\tt processLine} to take the {\tt cities} object
as a second parameter.

\section {{\tt apmatrix}}
\index{matrix}
\index{apmatrix}

An {\tt apmatrix} is similar to an {\tt apvector} except it
is two-dimensional.  Instead of a length, it has two
dimensions, called {\tt numrows} and {\tt numcols}, for
``number of rows'' and ``number of columns.''

Each element in the matrix is indentified by two indices;
one specifies the row number, the other the column number.

\index{index}

To create a matrix, there are four constructors:

\begin{verbatim}
  apmatrix<char> m1;
  apmatrix<int> m2 (3, 4);
  apmatrix<double> m3 (rows, cols, 0.0);
  apmatrix<double> m4 (m3);
\end{verbatim}
%
The first is a do-nothing constructor that makes a matrix with both
dimensions 0.  The second takes two integers, which are the initial
number of rows and columns, in that order.  The third is the same as
the second, except that it takes an additional parameter that is used
to initialized the elements of the matrix.  The fourth is a copy
constructor that takes another {\tt apmatrix} as a parameter.

\index{constructor}

Just as with {\tt apvectors}, we can make {\tt apmatrix}es with any
type of elements (including {\tt apvector}s, and even {\tt
apmatrix}es).

To access the elements of a matrix, we use the {\tt []} operator
to specify the row and column:

\begin{verbatim}
  m2[0][0] = 1;
  m3[1][2] = 10.0 * m2[0][0];
\end{verbatim}
%
If we try to access an element that is out of range, the program
prints an error message and quits.

\index{run-time error}

The {\tt numrows} and {\tt numcols} functions get the number of
rows and columns.  Remember that the row indices run from 0 to
{\tt numrows() -1} and the column indices run from 0 to
{\tt numcols() -1}.

\index{loop!nested}

The usual way to traverse a matrix is with a nested loop.
This loop sets each element of the matrix to the sum of its
two indices:

\begin{verbatim}
  for (int row=0; row < m2.numrows(); row++) {
    for (int col=0; col < m2.numcols(); col++) {
      m2[row][col] = row + col;
    }
  }
\end{verbatim}
%
This loop prints each row of the matrix with tabs between the
elements and newlines between the rows:

\begin{verbatim}
  for (int row=0; row < m2.numrows(); row++) {
    for (int col=0; col < m2.numcols(); col++) {
      cout << m2[row][col] << "\t";
    }
    cout << endl;
  }
\end{verbatim}
%

\section{A distance matrix}

Finally, we are ready to put the data from the file into
a matrix.  Specifically, the matrix will have one row and
one column for each city.

We'll create the matrix in {\tt main}, with plenty of space
to spare:

\begin{verbatim}
  apmatrix<int> distances (50, 50, 0);
\end{verbatim}
%

Inside {\tt processLine}, we add new information to the
matrix by getting the indices of the two cities from the
{\tt Set} and using them as matrix indices:

\begin{verbatim}
  int dist = convertToInt (distString);
  int index1 = cities.add (city1);
  int index2 = cities.add (city2);

  distances[index1][index2] = distance;
  distances[index2][index1] = distance;
\end{verbatim}
%
Finally, in {\tt main} we can print the information in a
human-readable form:

\begin{verbatim}
  for (int i=0; i<cities.getNumElements(); i++) {
    cout << cities.getElement(i) << "\t";

    for (int j=0; j<=i; j++) {
      cout << distances[i][j] << "\t";
    }
    cout << endl;
  }

  cout << "\t";
  for (int i=0; i<cities.getNumElements(); i++) {
    cout << cities.getElement(i) << "\t";
  }
  cout << endl;
\end{verbatim}
%
This code produces the output shown at the beginning of the
chapter.  The original data is available from this book's web page.

\section{A proper distance matrix}

Although this code works, it is not as well organized as it
should be.  Now that we have written a prototype, we are in a
good position to evaluate the design and improve it.

What are some of the problems with the existing code?

\begin{enumerate}

\item We did not know ahead of time how big to make the distance
matrix, so we chose an arbitrary large number (50) and made it
a fixed size.  It would be better to allow the distance matrix
to expand in the same way a {\tt Set} does.  The {\tt apmatrix}
class has a function called {\tt resize} that makes this possible.

\index{resize}

\item The data in the distance matrix is not well-encapsulated.
We have to pass the set of city names and the matrix itself
as arguments to {\tt processLine}, which is awkward.  Also,
use of the distance matrix is error prone because we have not
provided accessor functions that perform error-checking.
It might be a good idea to take the {\tt Set} of city names
and the {\tt apmatrix} of distances, and combine them into a
single object called a {\tt DistMatrix}.

\end{enumerate}

Here is a draft of what the header for a {\tt DistMatrix}
might look like:

\begin{verbatim}
class DistMatrix {
private:
  Set cities;
  apmatrix<int> distances;

public:
  DistMatrix (int rows);

  void add (const apstring& city1, const apstring& city2, int dist);
  int distance (int i, int j) const;
  int distance (const apstring& city1, const apstring& city2) const;
  apstring cityName (int i) const;
  int numCities () const;
  void print ();
};
\end{verbatim}
%
Using this interface simplifies {\tt main}:

\begin{verbatim}
#include <iostream>
#include <fstream>
using namespace std;


int main ()
{
  apstring line;
  ifstream infile ("distances");
  DistMatrix distances (2);

  while (true) {
    getline (infile, line);
    if (infile.eof()) break;
    processLine (line, distances);
  }

  distances.print ();
  return 0;
}
\end{verbatim}
%
It also simplifies {\tt processLine}:

\begin{verbatim}
void processLine (const apstring& line, DistMatrix& distances)
{
  char quote = '\"';
  apvector<int> quoteIndex (4);
  quoteIndex[0] = line.find (quote);
  for (int i=1; i<4; i++) {
    quoteIndex[i] = find (line, quote, quoteIndex[i-1]+1);
  }

  // break the line up into substrings
  int len1 = quoteIndex[1] - quoteIndex[0] - 1;
  apstring city1 = line.substr (quoteIndex[0]+1, len1);
  int len2 = quoteIndex[3] - quoteIndex[2] - 1;
  apstring city2 = line.substr (quoteIndex[2]+1, len2);
  int len3 = line.length() - quoteIndex[2] - 1;
  apstring distString = line.substr (quoteIndex[3]+1, len3);
  int distance = convertToInt (distString);

  // add the new datum to the distances matrix
  distances.add (city1, city2, distance);
}
\end{verbatim}
%
I will leave it as an exercise to you to implement the
member functions of {\tt DistMatrix}.


\section{Glossary}

\begin{description}

\item[ordered set:]  A data structure in which every element appears
only once and every element has an index that identifies it.

\item[stream:]  A data structure that represents a ``flow'' or
sequence of data items from one place to another.  In C++ streams
are used for input and output.

\item[accumulator:]  A variable used inside a loop to accumulate
a result, often by getting something added or concatenated during each
iteration.

\index{ordered set}
\index{set!ordered}
\index{stream}
\index{accumulator}
\index{pattern!accumulator}

\end{description}

\end{document}

